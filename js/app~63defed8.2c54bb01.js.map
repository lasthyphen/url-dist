{"version":3,"sources":["webpack:///./src/helpers/account_helper.ts","webpack:///./src/js/wallets/MnemonicWallet.ts","webpack:///./src/js/ERC721Token.ts","webpack:///./src/js/AvaNetwork.ts","webpack:///./src/js/Erc20Token.ts","webpack:///./src/js/TxHelper.ts","webpack:///./src/js/Crypto.ts","webpack:///./src/js/Keystore.ts","webpack:///./src/explorer_api.ts","webpack:///./src/evm.ts","webpack:///./src/helpers/price_helper.ts","webpack:///./src/js/HdHelper.ts","webpack:///./src/js/wallets/HdWalletCore.ts","webpack:///./src/helpers/history_helper.ts","webpack:///./src/js/wallets/LedgerWallet.ts","webpack:///./src/helpers/issueTx.ts","webpack:///./src/helpers/getRandomMnemonicWord.ts","webpack:///./src/locales/lang_map.js","webpack:///./src/js/wallets/MnemonicPhrase.ts","webpack:///./src/helpers/utxo_helper.ts","webpack:///./src/js/wallets/SingletonWallet.ts","webpack:///./src/js/AvaNftFamily.ts","webpack:///./src/js/wallets/WalletCore.ts","webpack:///./src/helpers/wallet_helper.ts","webpack:///./src/helpers/helper.ts","webpack:///./src/js/AvaAsset.ts"],"names":["getAccountByIndex","index","getLocalStorageAccounts","removeAccountByIndex","accounts","splice","saveLocalStorageJSONItem","getLocalStorageJSONItem","key","item","localStorage","getItem","JSON","parse","data","formatted","stringify","setItem","addAccountToStorage","account","push","verifyAccountPassword","password","wallet","overwriteAccountAtIndex","newAccount","accts","AVA_TOKEN_INDEX","AVA_ACCOUNT_PATH","ETH_ACCOUNT_PATH","LEDGER_ETH_ACCOUNT_PATH","mnemonic","seed","masterHdKey","fromMasterSeed","accountHdKey","derive","ethAccountKey","ethPrivateKey","privateKey","ethKey","toString","ethAddress","ethBalance","cPrivKey","cb58Encode","from","ethKeyBech","cKeyChain","getHRP","ethKeyChain","importKey","type","hdKey","isLoading","onnetworkchange","this","getEvmAddress","getEthBalance","bal","sendEth","to","amount","gasPrice","gasLimit","estimateGas","token","Promise","sendERC20","sendErc20","getUTXOs","isFetchUtxos","isInit","externalHelper","internalHelper","platformHelper","getStake","setTimeout","getCurrentKey","getMnemonic","getValue","getMnemonicEncrypted","validate","nodeID","amt","start","end","delegationFee","rewardAddress","utxos","delegate","stakeAmount","issueBatchTx","orders","addr","memo","getKeyChain","internal","getAllDerivedKeys","external","allKeys","concat","keychain","getNetworkID","chainId","i","length","addKey","signX","unsignedTx","tx","sign","signP","getKeychain","signC","keyChain","signEvm","keyBuff","Buffer","signHashByExternalIndex","hash","getKeyForIndex","signed","createNftFamily","name","symbol","groupNum","mintNft","mintUtxo","payload","quantity","ERC721MetadataID","ERC721EnumerableID","tokenCache","uriDataCache","canSupport","contractAddress","address","contract","eth","Contract","abi","updateSupports","methods","supportsInterface","call","metadata","enumerable","getBalance","balanceOf","getAllTokensIds","res","tokenOfOwnerByIndex","tokenId","getAllTokenData","ids","id","getTokenURI","parseInt","createTransferTx","transferFrom","tokenURI","getTokenURIData","uri","a","get","network_id","url","networkId","explorerUrl","explorerSiteUrl","readonly","withCredentials","protocol","port","ip","updateURL","testConnection","credentials","post","jsonrpc","method","catch","err","updateCredentials","split","includes","urlSplit","getFullURL","getWsUrlX","getWsUrlC","tokenData","balanceRaw","balanceBN","balanceBig","tokenInst","fromAddress","console","log","transfer","updateBalance","decimals","AvmTxNameEnum","PlatfromTxNameEnum","ParseableAvmTxEnum","ParseablePlatformEnum","ParseableEvmTxEnum","buildUnsignedTransaction","derivedAddresses","utxoset","changeAddress","fromAddrsStr","fromAddrs","map","val","parseAddress","changeAddr","stringToAddress","getDJTXAssetID","DJTX_ID_BUF","DJTX_ID_STR","TO_BUF","aad","ZERO","isFeeAdded","order","asset","assetId","cb58Decode","addAssetAmount","getTxFee","gt","success","getMinimumSpendable","ins","outs","getInputs","getAllOutputs","nftUtxos","filter","getBlockchainID","nftSet","addArray","utxoIds","getUTXOIDs","sort","b","buildNFTTransferTx","undefined","rawTx","getTransaction","outsNft","getOuts","insNft","getIns","baseTx","buildCreateNftFamilyTx","minterAddr","utxoSet","fromAddresses","minterAddress","minterSets","minterSet","buildCreateNFTAssetTx","buildMintNftTx","ownerAddress","addrBuf","owners","sourceAddresses","owner","groupID","getOutput","getGroupID","buildCreateNFTMintTx","getUTXOID","mintTx","buildEvmTransferNativeTx","getTransactionCount","nonce","getChainId","net","getId","chainParams","common","forCustomChain","value","buildEvmTransferErc20Tx","tokenTx","encodeABI","buildEvmTransferErc721Tx","BASETX","CREATEASSETTX","OPERATIONTX","IMPORTTX","EXPORTTX","ADDVALIDATORTX","ADDDELEGATORTX","ADDSUBNETVALIDATORTX","CREATECHAINTX","CREATESUBNETTX","ADVANCETIMETX","REWARDVALIDATORTX","ivSize","saltSize","tagLength","aesLength","keygenIterations","_pwcleaner","slt","pw","sha256","_keyMaterial","pwkey","window","crypto","subtle","Uint8Array","_deriveKey","keyMaterial","salt","deriveKey","iterations","message","buff","update","digest","makeSalt","alloc","getRandomValues","pwhash","encrypt","plaintext","pt","pkey","iv","additionalData","ciphertext","decrypt","cryptoHelpers","Crypto","KEYSTORE_VERSION","ITERATIONS_V2","ITERATIONS_V3","readV2","pass","version","pass_hash","checkHash","checkHashString","keys","keysDecrypt","key_data","key_decrypt","key_string","activeIndex","readV3","readV4","readV5","readV6","readKeyFile","extractKeysV2","file","chainID","getBlockchainAlias","pk","keypair","keyBuf","getPrivateKey","keyHex","paddedKeyHex","padStart","extractKeysV5","extractKeysV6","extractKeysFromDecryptedFile","makeKeyfile","wallets","pk_crypt","file_data","api_url","explorer_api","create","baseURL","headers","getAddressHistory","addrs","limit","endTime","ADDR_SIZE","selection","slice","remaining","addrsRaw","rootUrl","req","disableCount","disableGenesis","txs","transactions","next","nextRes","getAddressChains","rawAddrs","urlRoot","addressChains","abiDecoder","addABI","rpcUrl","web3","axios","COIN_ID","COINGECKO_URL","coingeckoApi","timeout","getDjtxPriceUSD","priceHistory","getPriceHistory","params","vs_currency","days","interval","prices","getPriceAtUnixTime","time","remainder","dayTimestamp","pricePair","find","INDEX_RANGE","SCAN_SIZE","SCAN_RANGE","changePath","masterKey","isPublic","isFetchUtxo","hrp","keyCache","addressCache","hdCache","hdIndex","oninit","findHdIndex","onNetworkChange","clearCache","incrementIndex","newIndex","newKey","network","store","state","Network","selectedNetwork","findAvailableIndexExplorer","findAvailableIndexNode","updateKeychain","updateUtxos","error","getAllDerivedAddresses","result","currentAddr","getCurrentAddress","currentAddrBuf","currentUtxos","getExtendedAddresses","getUtxos","upTo","set","getAddressForIndex","startIndex","addrChains","gapSize","n","scanIndex","scanAddr","rawAddr","chains","addrUTXOs","targetIndex","getFirstAvailableIndex","getFirstAvailableAddress","idx","isPrivate","cacheExternal","pkHex","derivationPath","publicKey","pkBuf","pkBuff","addressFromPublicKey","addressToString","findAddressIndex","indexOf","ethHdNode","accountNodeXP","then","updateInitState","getXpubXP","toJSON","xpub","getEvmAddressBech","pubKeyHash","updateAvmUTXOSet","setExternal","setInternal","joined","merge","getFirstAvailableAddressPlatform","updateFetchState","updateUTXOsX","updateUTXOsP","updateUTXOsExternal","updateUTXOsInternal","getAllDerivedExternalAddresses","getDerivedAddresses","getDerivedAddressesP","getAllAddressesX","getAllAddressesP","getHistoryAddresses","internalIndex","externalIndex","Math","max","getCurrentAddressAvm","getChangeAddressAvm","getChangeAddressPlatform","getChangePath","getChangeIndex","getChangeFromIndex","getPlatformRewardAddress","getCurrentAddressPlatform","getPlatformUTXOSet","getPlatformActiveIndex","getExternalActiveIndex","getBaseAddress","getUTXOSet","findExternalAddressIndex","indexX","indexP","Error","signMessageByExternalAddress","msgStr","signMessageByExternalIndex","digestHex","digestBuff","signMessage","msg","WalletCore","addToDict","dict","utxo","addresses","add","addrDiff","getNFTsSummary","nftLoss","getLossNFT","nftGain","getGainNFT","sent","received","walletAddrs","addrsStripped","inputs","outputs","loss","assets","nfts","input","output","outputType","NFTXFEROUTPUTID","nftsOuts","assetID","intersect","nftOut","doesMatch","addrNotAdded","gain","nftsIns","nftIn","getLoss","isNft","amountBN","receivers","forEach","outAddrs","targets","getProfit","profit","senders","getTransactionSummary","losses","profits","nftSummary","sum","tokens","collectibles","mul","filterDuplicateTransactions","txsIds","filtered","txId","bippath","MIN_EVM_SUPPORT_V","app","hdkey","config","hdEth","ethApp","ethPublic","fromApp","getWalletExtendedPublicKey","hd","public_key","chainCode","chain_code","getAddress","ethRes","LedgerWallet","getTransactionPaths","toBuffer","txType","getTxType","operations","getOperations","e","items","getImportInputs","paths","isDjtxOnly","getAssetID","Assets","AVA_ASSET_ID","sigidxs","getInput","getSigIdxs","sources","sigidx","source","j","srcAddr","pathStr","getPathFromAddress","op","getOperation","pathsToUniqueBipPaths","uniquePaths","bip32Paths","path","fromString","getChangeBipPath","chainChangePath","changeIdx","getCredentials","sigMap","CredentialClass","creds","evmInputs","cred","getCredentialID","pathIndex","sigRaw","sigBuff","sig","fromBuffer","addSignature","evmInput","signTransactionHash","txbuff","commit","title","messages","info","toUpperCase","accountPathSource","accountPath","signHash","signedTx","signTransactionParsable","parseableTxs","X","P","C","getTransactionMessages","signTransaction","ledgerSignedTx","signatures","getOutputMsgs","getExportOutputs","getExportedOutputs","destinationChain","getAmount","toPathArray","getAddresses","getValidateDelegateMsgs","format","getNodeID","startTime","getStartTime","toNumber","utc","getEndTime","stakeAmt","getStakeAmount","rewardOwners","getRewardOwners","rewardAddrs","join","getFeeMsgs","outputMessages","validateDelegateMessages","feeMessages","getEvmTransactionMessages","totFee","feeNano","msgs","test","decodeMethod","callMsg","paramMsgs","param","feeMsg","toLocaleString","canLedgerParse","isParsableType","txIns","typeID","getTypeID","STAKEABLELOCKINID","destChainBuff","getDestinationChain","destChain","sourceChainBuff","getSourceChain","sourceChain","typeId","txSigned","rawUnsignedTx","encode","buf","signature","signatureBN","v","r","s","fromTxData","externalAddrs","internalAddrs","platformAddrs","extIndex","intIndex","platformIndex","addressPath","issueX","issueTx","addChecksum","issueP","issueC","getRandomMnemonicWord","words","rand","round","random","isoLangs","ab","nativeName","aa","af","ak","sq","am","ar","an","hy","as","av","ae","ay","az","bm","ba","eu","be","bn","bh","bi","bs","br","bg","my","ca","ch","ce","ny","cn","zh_hans","zh_hant","cv","kw","co","cr","hr","cs","da","dv","nl","en","eo","et","ee","fo","fj","fi","fr","ff","gl","ka","de","el","gn","gu","ht","ha","he","hz","hi","ho","hu","ia","ie","ga","ig","ik","io","is","it","iu","ja","jv","kl","kn","ks","kk","km","ki","rw","ky","kv","kg","kr","ku","kj","la","lb","lg","li","ln","lo","lt","lu","lv","gv","mk","mg","ms","ml","mt","mi","mr","mh","mn","na","nv","nb","nd","ne","ng","nn","no","ii","nr","oc","oj","cu","om","or","os","pa","pi","fa","pl","ps","qu","rm","rn","ro","ru","sa","sc","sd","se","sm","sg","sr","gd","sn","si","sk","sl","so","st","es","su","sw","ss","sv","ta","te","tg","th","ti","bo","tk","tl","tn","tr","ts","tt","tw","ty","ug","uk","ur","uz","ve","vn","vo","wa","cy","wo","fy","xh","yi","yo","za","randomstring","generate","encrypted","decrypted","enc","Utf8","getStakeForAddresses","stakeData","staked","chunk","remainingChunk","chunkStake","avmGetAllUTXOs","avmGetAllUTXOsForAddresses","newSet","endIndex","response","getAllUTXOs","nextEndIndex","len","numFetched","subUtxos","platformGetAllUTXOs","platformGetAllUTXOsForAddresses","chainIdP","keyPair","platformKeyChain","platformKeyPair","pkBuffNative","cKeypair","ethAddressBech","getAddressString","getExtendedPlatformAddresses","platformUtxoset","uniqid","evmGetAtomicUTXOs","createImportTxC","fee","bechAddr","hexAddr","toAddress","ownerAddresses","sourceChainId","buildImportTx","importToCChain","unsignedTxFee","exportFromXChain","importFee","amtFee","clone","destinationAddr","buildAvmExportTransaction","exportTx","exportFromPChain","pChangeAddr","buildPlatformExportTransaction","exportFromCChain","exportFee","buildEvmExportTransaction","estimateExportFee","estimateExportGasFee","avmGetAtomicUTXOs","platformGetAtomicUTXOs","importToPlatformChain","pToAddr","utxoAddrs","ownerAddrs","importToXChain","xToAddr","pAddressStrings","stakeReturnAddr","getTime","buildAddValidatorTx","buildAddDelegatorTx","fromAddr","txHex","serialize","sendSignedTransaction","transactionHash","sendErc721","estimateTxGas","estGas","bnToBig","denomination","div","pow","keyToKeypair","calculateStakingReward","duration","currentSupply","networkID","defValues","defPlatformVals","maxConsumption","minConsumption","diffConsumption","maxSupply","maxStakingDuration","remainingSupply","sub","amtBig","currentSupplyBig","remainingSupplyBig","portionOfExistingSupplyBig","portionOfStakingDuration","mintingRate","rewardBig","times","rewardStr","toFixed","rewardBN","digestMessage","mBuf","msgSize","writeUInt32BE","msgBuf","payloadtypes","getInstance","getPayloadFromUTXO","out","getPayloadBuffer","getContent","payloadbase","select","amountLocked","amountExtra","amountMultisig","addBalance","addBalanceLocked","addBalanceMultisig","addExtra","resetBalance","locked","getAmountBN","getTotalAmount","toStringTotal","big"],"mappings":"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","file":"js/app~63defed8.2c54bb01.js","sourcesContent":["import { iUserAccountEncrypted } from '@/store/types'\nimport { WalletType } from '@/js/wallets/types'\nimport isEqual from 'lodash.isequal'\nimport differenceBy from 'lodash.differenceby'\nimport { readKeyFile } from '@/js/Keystore'\n\nconst checkAccountsExist = (): boolean => {\n    return localStorage.getItem('accounts') !== null\n}\n\nexport function getAccountByIndex(index: number): iUserAccountEncrypted | null {\n    return getLocalStorageAccounts()[index] || null\n}\n\nexport const checkIfSavedLocally = (allWallets: WalletType[]): boolean => {\n    const exists = checkAccountsExist()\n\n    if (!exists) return false\n\n    const ethAddressArray: string[] = allWallets.map((x: WalletType) => x.ethAddress)\n\n    const savedAccounts: iUserAccountEncrypted[] = getLocalStorageJSONItem('accounts')\n\n    for (const each of savedAccounts) {\n        if (isEqual(each.baseAddresses, ethAddressArray)) {\n            return true\n        }\n    }\n\n    return false\n}\nexport const removeAccountByIndex = (index: number): void => {\n    const accounts: iUserAccountEncrypted[] = getLocalStorageAccounts()\n    accounts.splice(index, 1)\n    saveLocalStorageJSONItem('accounts', accounts)\n}\n\nexport const getLocalStorageJSONItem = (key: string) => {\n    const item = localStorage.getItem(key)\n    if (item !== null) {\n        return JSON.parse(item)\n    }\n}\n\nexport function getLocalStorageAccounts(): iUserAccountEncrypted[] {\n    return getLocalStorageJSONItem('accounts') || []\n}\n\nexport const saveLocalStorageJSONItem = (key: string, data: any) => {\n    const formatted = JSON.stringify(data)\n    localStorage.setItem(key, formatted)\n}\n\nexport const getIndexByWallets = (wallets: WalletType[]): number | null => {\n    const ethAddressArray: string[] = wallets.map((x: WalletType) => x.getEvmAddress())\n    const savedAccounts: iUserAccountEncrypted[] = getLocalStorageAccounts()\n    const index = 0\n    for (let i = 0; i < savedAccounts.length; i++) {\n        const acct = savedAccounts[i]\n        if (isEqual(acct.baseAddresses, ethAddressArray)) {\n            return index\n        }\n    }\n    return null\n}\n\nexport const getNonVolatileWallets = (\n    allWallets: WalletType[],\n    volatileWallets: WalletType[]\n): WalletType[] | [] => {\n    const diff = differenceBy(allWallets, volatileWallets, 'ethAddress')\n    diff === undefined ? [] : diff\n    return diff\n}\n\nexport function addAccountToStorage(account: iUserAccountEncrypted) {\n    const accounts = getLocalStorageAccounts()\n    accounts.push(account)\n    saveLocalStorageJSONItem('accounts', accounts)\n}\n\n// Given a password and an account, will verify if its the correct password\nexport async function verifyAccountPassword(account: iUserAccountEncrypted, password: string) {\n    try {\n        const res = await readKeyFile(account.wallet, password)\n        return true\n    } catch (err) {\n        return false\n    }\n}\n\nexport function overwriteAccountAtIndex(newAccount: iUserAccountEncrypted, index: number) {\n    const accts = getLocalStorageAccounts()\n    accts.splice(index, 1, newAccount)\n    saveLocalStorageJSONItem('accounts', accts)\n}\n\nexport default {\n    removeAccountByIndex,\n    checkIfSavedLocally,\n    getNonVolatileWallets,\n}\n","// A simple wrapper thar combines avalanche.js, bip39 and HDWallet\n\nimport {\n    KeyPair as AVMKeyPair,\n    KeyChain as AVMKeyChain,\n    UTXOSet as AVMUTXOSet,\n    TransferableInput,\n    TransferableOutput,\n    BaseTx,\n    UnsignedTx as AVMUnsignedTx,\n    Tx as AVMTx,\n    UTXO as AVMUTXO,\n    AssetAmountDestination,\n    UTXOSet,\n} from 'avalanche/dist/apis/avm'\n\nimport { privateToAddress } from 'ethereumjs-util'\n\nimport {\n    KeyChain as PlatformVMKeyChain,\n    UnsignedTx as PlatformUnsignedTx,\n    UTXO as PlatformUTXO,\n    Tx as PlatformTx,\n} from 'avalanche/dist/apis/platformvm'\n\nimport {\n    KeyChain as EVMKeyChain,\n    UnsignedTx as EVMUnsignedTx,\n    Tx as EvmTx,\n} from 'avalanche/dist/apis/evm'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\n\nimport * as bip39 from 'bip39'\nimport { BN, Buffer as BufferAvalanche } from 'avalanche'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { AvmExportChainType, AvmImportChainType, IAvaHdWallet } from '@/js/wallets/types'\nimport HDKey from 'hdkey'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { KeyPair as PlatformVMKeyPair } from 'avalanche/dist/apis/platformvm'\nimport { HdWalletCore } from '@/js/wallets/HdWalletCore'\nimport { WalletNameType } from '@/js/wallets/types'\nimport { digestMessage } from '@/helpers/helper'\nimport { KeyChain } from 'avalanche/dist/apis/evm'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletHelper } from '@/helpers/wallet_helper'\nimport { Transaction } from '@ethereumjs/tx'\nimport MnemonicPhrase from '@/js/wallets/MnemonicPhrase'\nimport { ExportChainsC, ExportChainsP } from '@avalabs/avalanche-wallet-sdk'\n\n// HD WALLET\n// Accounts are not used and the account index is fixed to 0\n// m / purpose' / coin_type' / account' / change / address_index\n\nconst AVA_TOKEN_INDEX: string = '9000'\nexport const AVA_ACCOUNT_PATH: string = `m/44'/${AVA_TOKEN_INDEX}'/0'` // Change and index left out\nexport const ETH_ACCOUNT_PATH: string = `m/44'/60'/0'`\nexport const LEDGER_ETH_ACCOUNT_PATH = ETH_ACCOUNT_PATH + '/0/0'\n\nconst INDEX_RANGE: number = 20 // a gap of at least 20 indexes is needed to claim an index unused\nconst SCAN_SIZE: number = 70 // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE // How many items are actually scanned\n\n// Possible indexes for each request is\n// SCAN_SIZE - INDEX_RANGE\n\nexport default class MnemonicWallet extends HdWalletCore implements IAvaHdWallet {\n    seed: string\n    hdKey: HDKey\n    private mnemonic: MnemonicPhrase\n    isLoading: boolean\n    type: WalletNameType\n    ethKey: string\n    ethKeyBech: string\n    ethKeyChain: EVMKeyChain\n    ethAddress: string\n    ethBalance: BN\n\n    // TODO : Move to hd core class\n    onnetworkchange() {\n        super.onnetworkchange()\n\n        // Update EVM values\n        this.ethKeyChain = new EVMKeyChain(ava.getHRP(), 'C')\n        const cKeypair = this.ethKeyChain.importKey(this.ethKeyBech)\n        this.ethBalance = new BN(0)\n    }\n\n    // The master key from avalanche.js\n    constructor(mnemonic: string) {\n        const seed: globalThis.Buffer = bip39.mnemonicToSeedSync(mnemonic)\n        const masterHdKey: HDKey = HDKey.fromMasterSeed(seed)\n        const accountHdKey = masterHdKey.derive(AVA_ACCOUNT_PATH)\n        const ethAccountKey = masterHdKey.derive(ETH_ACCOUNT_PATH + '/0/0')\n\n        super(accountHdKey, ethAccountKey, false)\n\n        // Derive EVM key and address\n        const ethPrivateKey = ethAccountKey.privateKey\n        this.ethKey = ethPrivateKey.toString('hex')\n        this.ethAddress = privateToAddress(ethPrivateKey).toString('hex')\n        this.ethBalance = new BN(0)\n\n        const cPrivKey = `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(ethPrivateKey))\n        this.ethKeyBech = cPrivKey\n\n        const cKeyChain = new KeyChain(ava.getHRP(), 'C')\n        this.ethKeyChain = cKeyChain\n\n        const cKeypair = cKeyChain.importKey(cPrivKey)\n\n        this.type = 'mnemonic'\n        this.seed = seed.toString('hex')\n        this.hdKey = masterHdKey\n        this.mnemonic = new MnemonicPhrase(mnemonic)\n        this.isLoading = false\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    async getEthBalance() {\n        const bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n\n    async getUTXOs(): Promise<void> {\n        // TODO: Move to shared file\n        this.isFetchUtxos = true\n        // If we are waiting for helpers to initialize delay the call\n        const isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n        if (!isInit) {\n            setTimeout(() => {\n                this.getUTXOs()\n            }, 1000)\n            return\n        }\n\n        super.getUTXOs()\n        this.getStake()\n        this.getEthBalance()\n        return\n    }\n\n    getCurrentKey(): AVMKeyPair {\n        return this.externalHelper.getCurrentKey() as AVMKeyPair\n    }\n\n    /**\n     * Returns the mnemonic phrase of this wallet\n     */\n    getMnemonic(): string {\n        return this.mnemonic.getValue()\n    }\n\n    getMnemonicEncrypted(): MnemonicPhrase {\n        return this.mnemonic\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number = 0,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    // Delegates DJTX to the given node ID\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: BufferAvalanche | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    // returns a keychain that has all the derived private/public keys for X chain\n    getKeyChain(): AVMKeyChain {\n        const internal = this.internalHelper.getAllDerivedKeys() as AVMKeyPair[]\n        const external = this.externalHelper.getAllDerivedKeys() as AVMKeyPair[]\n\n        const allKeys = internal.concat(external)\n        const keychain: AVMKeyChain = new AVMKeyChain(\n            getPreferredHRP(ava.getNetworkID()),\n            this.chainId\n        )\n\n        for (let i = 0; i < allKeys.length; i++) {\n            keychain.addKey(allKeys[i])\n        }\n        return keychain\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        const keychain = this.getKeyChain()\n\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        const keychain = this.platformHelper.getKeychain() as PlatformVMKeyChain\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        const keyChain = this.ethKeyChain\n        return unsignedTx.sign(keyChain)\n    }\n\n    async signEvm(tx: Transaction) {\n        const keyBuff = Buffer.from(this.ethKey, 'hex')\n        return tx.sign(keyBuff)\n    }\n\n    async signHashByExternalIndex(index: number, hash: BufferAvalanche) {\n        const key = this.externalHelper.getKeyForIndex(index) as AVMKeyPair\n        const signed = key.sign(hash)\n        return bintools.cb58Encode(signed)\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n}\n","import { web3 } from '@/evm'\nimport ERC721Abi from '@openzeppelin/contracts/build/contracts/ERC721Enumerable.json'\nimport { ERC721TokenInput } from '@/store/modules/assets/modules/types'\nimport axios from 'axios'\n\ninterface TokenDataCache {\n    [index: number]: string\n}\n\ninterface URIDataCache {\n    [index: number]: string\n}\n\nconst ERC721MetadataID = '0x5b5e139f'\nconst ERC721EnumerableID = '0x780e9d63'\n\nclass ERC721Token {\n    contractAddress: string\n    contract: any\n    name = ''\n    symbol = ''\n    data: ERC721TokenInput\n    tokenCache: TokenDataCache = {}\n    uriDataCache: URIDataCache = {}\n    canSupport = false\n\n    constructor(data: ERC721TokenInput) {\n        this.contractAddress = data.address\n        this.name = data.name\n        this.symbol = data.symbol\n        this.data = data\n        //@ts-ignore\n        this.contract = new web3.eth.Contract(ERC721Abi.abi, this.contractAddress)\n        this.updateSupports()\n    }\n\n    async updateSupports() {\n        try {\n            const metadata = await this.contract.methods.supportsInterface(ERC721MetadataID).call()\n            const enumerable = await this.contract.methods\n                .supportsInterface(ERC721EnumerableID)\n                .call()\n            this.canSupport = metadata && enumerable\n        } catch (err) {\n            this.canSupport = false\n        }\n    }\n\n    async getBalance(address: string) {\n        return await this.contract.methods.balanceOf(address).call()\n    }\n\n    async getAllTokensIds(address: string): Promise<string[]> {\n        if (!this.canSupport) return []\n\n        const bal = await this.getBalance(address)\n        const res = []\n        for (let i = 0; i < bal; i++) {\n            const tokenId = await this.contract.methods.tokenOfOwnerByIndex(address, i).call()\n            res.push(tokenId)\n        }\n        return res\n    }\n\n    async getAllTokenData(address: string) {\n        const ids = await this.getAllTokensIds(address)\n\n        const res = []\n        for (let i = 0; i < ids.length; i++) {\n            const id = ids[i]\n            const data = await this.getTokenURI(parseInt(id))\n            res.push(data)\n        }\n        return res\n    }\n\n    createTransferTx(from: string, to: string, id: string) {\n        return this.contract.methods.transferFrom(from, to, id)\n    }\n\n    async getTokenURI(id: number) {\n        if (this.tokenCache[id]) return this.tokenCache[id]\n        const data = await this.contract.methods.tokenURI(id).call()\n        this.tokenCache[id] = data\n        return data\n    }\n\n    async getTokenURIData(id: number): Promise<any> {\n        //Check cache\n        if (this.uriDataCache[id]) return this.uriDataCache[id]\n        const uri = await this.getTokenURI(id)\n        if (!uri) return null\n        const res = (await axios.get(uri)).data\n        //Save to cache\n        this.uriDataCache[id] = res\n        return res\n    }\n}\n\nexport default ERC721Token\n","import axios from 'axios'\n\nlet network_id: number = 0\n\nclass AvaNetwork {\n    name: string\n    id: number\n    protocol: string\n    port: number\n    ip: string\n    networkId: number\n    // chainId: string;\n    url: string\n    explorerUrl: string | undefined\n    explorerSiteUrl: string | undefined\n    readonly: boolean\n    withCredentials = false\n    // fee: BN\n\n    constructor(\n        name: string,\n        url: string,\n        networkId: number,\n        explorerUrl?: string,\n        explorerSiteUrl?: string,\n        readonly = false\n    ) {\n        this.id = network_id++\n        this.name = name\n        this.explorerUrl = explorerUrl\n        this.explorerSiteUrl = explorerSiteUrl\n        this.protocol = 'http'\n        this.port = 9650\n        this.ip = 'localhost'\n        this.url = url\n        this.updateURL(url)\n        this.networkId = networkId\n        // this.chainId = chainId;\n        this.readonly = readonly\n        // this.fee = new BN(0);\n    }\n\n    async testConnection(credentials = false) {\n        const resp = await axios\n            .post(\n                this.url + '/ext/info',\n                {\n                    jsonrpc: '2.0',\n                    id: 1,\n                    method: 'info.getNetworkID',\n                },\n                {\n                    withCredentials: true,\n                }\n            )\n            .catch((err) => {\n                return false\n            })\n\n        return true\n    }\n\n    // Checks if this network endpoint allows credentials\n    async updateCredentials() {\n        try {\n            const res = await axios.post(\n                this.url + '/ext/info',\n                {\n                    jsonrpc: '2.0',\n                    id: 1,\n                    method: 'info.getNetworkID',\n                },\n                {\n                    withCredentials: true,\n                }\n            )\n            this.withCredentials = true\n        } catch (e) {\n            this.withCredentials = false\n        }\n    }\n\n    updateURL(url: string) {\n        const split: string[] = url.split('://')\n\n        this.protocol = split[0]\n\n        // port is set\n        if (split[1].includes(':')) {\n            const urlSplit: string[] = split[1].split(':')\n            const ip: string = urlSplit[0]\n            const port: string = urlSplit[1]\n\n            this.ip = ip\n            this.port = parseInt(port)\n        } else {\n            this.ip = split[1]\n            if (this.protocol === 'http') {\n                this.port = 80\n            } else {\n                this.port = 443\n            }\n        }\n    }\n    getFullURL() {\n        return `${this.protocol}://${this.ip}:${this.port}`\n    }\n\n    getWsUrlX(): string {\n        const protocol = this.protocol === 'https' ? 'wss' : 'ws'\n        return `${protocol}://${this.ip}:${this.port}/ext/bc/X/events`\n    }\n\n    getWsUrlC(): string {\n        const protocol = this.protocol === 'https' ? 'wss' : 'ws'\n        return `${protocol}://${this.ip}:${this.port}/ext/bc/C/ws`\n    }\n}\n\nexport { AvaNetwork }\n","import { TokenListToken } from '@/store/modules/assets/types'\nimport { web3 } from '@/evm'\nimport { BN } from 'avalanche'\nimport { bnToBig } from '@/helpers/helper'\nimport Big from 'big.js'\nimport store from '@/store'\n\nimport ERC20Abi from '@openzeppelin/contracts/build/contracts/ERC20.json'\n\nclass Erc20Token {\n    data: TokenListToken\n    contract: any\n    balanceRaw: string\n    balanceBN: BN\n    balanceBig: Big\n\n    constructor(tokenData: TokenListToken) {\n        this.data = tokenData\n        this.balanceRaw = '0'\n        this.balanceBN = new BN('0')\n        this.balanceBig = Big(0)\n\n        //@ts-ignore\n        const tokenInst = new web3.eth.Contract(ERC20Abi.abi, tokenData.address)\n        this.contract = tokenInst\n    }\n\n    // Returns a new instance of the token, given only the erc20 address\n    static fromAddress(address: string) {\n        //@ts-ignore\n        const tokenInst = new web3.eth.Contract(ERC20Abi.abi, address)\n        console.log(tokenInst)\n    }\n\n    createTransferTx(to: string, amount: BN) {\n        return this.contract.methods.transfer(to, amount.toString())\n    }\n\n    async updateBalance(address: string) {\n        const bal = await this.contract.methods.balanceOf('0x' + address).call()\n        this.balanceRaw = bal\n        this.balanceBN = new BN(bal)\n        this.balanceBig = bnToBig(this.balanceBN, parseInt(this.data.decimals as string))\n    }\n}\n\nexport default Erc20Token\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { BN, Buffer } from 'avalanche'\nimport {\n    AssetAmountDestination,\n    BaseTx,\n    MinterSet,\n    NFTMintOutput,\n    TransferableInput,\n    TransferableOutput,\n    UnsignedTx as AVMUnsignedTx,\n    UTXO as AVMUTXO,\n    UTXOSet,\n    UTXOSet as AVMUTXOSet,\n    AVMConstants,\n} from 'avalanche/dist/apis/avm'\n\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { OutputOwners } from 'avalanche/dist/common'\nimport { PlatformVMConstants } from 'avalanche/dist/apis/platformvm'\n\nimport { UnsignedTx as EVMUnsignedTx, EVMConstants } from 'avalanche/dist/apis/evm'\n\nimport { web3 } from '@/evm'\nimport ERC721Token from '@/js/ERC721Token'\nimport { Transaction } from '@ethereumjs/tx'\nimport EthereumjsCommon from '@ethereumjs/common'\nimport Erc20Token from '@/js/Erc20Token'\n\nexport async function buildUnsignedTransaction(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    derivedAddresses: string[],\n    utxoset: AVMUTXOSet,\n    changeAddress?: string,\n    memo?: Buffer\n) {\n    // TODO: Get new change index.\n    if (!changeAddress) {\n        throw 'Unable to issue transaction. Ran out of change index.'\n    }\n\n    const fromAddrsStr: string[] = derivedAddresses\n    const fromAddrs: Buffer[] = fromAddrsStr.map((val) => bintools.parseAddress(val, 'X'))\n    const changeAddr: Buffer = bintools.stringToAddress(changeAddress)\n\n    // TODO: use internal asset ID\n    // This does not update on network change, causing issues\n    const DJTX_ID_BUF = await avm.getDJTXAssetID()\n    const DJTX_ID_STR = DJTX_ID_BUF.toString('hex')\n    const TO_BUF = bintools.stringToAddress(addr)\n\n    const aad: AssetAmountDestination = new AssetAmountDestination([TO_BUF], fromAddrs, [\n        changeAddr,\n    ])\n    const ZERO = new BN(0)\n    let isFeeAdded = false\n\n    // Aggregate Fungible ins & outs\n    for (let i: number = 0; i < orders.length; i++) {\n        const order: ITransaction | AVMUTXO = orders[i]\n\n        if ((order as ITransaction).asset) {\n            // if fungible\n            const tx: ITransaction = order as ITransaction\n\n            const assetId = bintools.cb58Decode(tx.asset.id)\n            const amt: BN = tx.amount\n\n            if (assetId.toString('hex') === DJTX_ID_STR) {\n                aad.addAssetAmount(assetId, amt, avm.getTxFee())\n                isFeeAdded = true\n            } else {\n                aad.addAssetAmount(assetId, amt, ZERO)\n            }\n        }\n    }\n\n    // If fee isn't added, add it\n    if (!isFeeAdded) {\n        if (avm.getTxFee().gt(ZERO)) {\n            aad.addAssetAmount(DJTX_ID_BUF, ZERO, avm.getTxFee())\n        }\n    }\n\n    const success: Error = utxoset.getMinimumSpendable(aad)\n\n    let ins: TransferableInput[] = []\n    let outs: TransferableOutput[] = []\n    if (typeof success === 'undefined') {\n        ins = aad.getInputs()\n        outs = aad.getAllOutputs()\n    } else {\n        throw success\n    }\n\n    //@ts-ignore\n    const nftUtxos: UTXO[] = orders.filter((val) => {\n        if ((val as ITransaction).asset) return false\n        return true\n    })\n\n    // If transferring an NFT, build the transaction on top of an NFT tx\n    let unsignedTx: AVMUnsignedTx\n    const networkId: number = ava.getNetworkID()\n    const chainId: Buffer = bintools.cb58Decode(avm.getBlockchainID())\n\n    if (nftUtxos.length > 0) {\n        const nftSet = new AVMUTXOSet()\n        nftSet.addArray(nftUtxos)\n\n        const utxoIds: string[] = nftSet.getUTXOIDs()\n\n        // Sort nft utxos\n        utxoIds.sort((a, b) => {\n            if (a < b) {\n                return -1\n            } else if (a > b) {\n                return 1\n            }\n            return 0\n        })\n\n        unsignedTx = nftSet.buildNFTTransferTx(\n            networkId,\n            chainId,\n            [TO_BUF],\n            fromAddrs,\n            fromAddrs, // change address should be something else?\n            utxoIds,\n            undefined,\n            undefined,\n            memo\n        )\n\n        const rawTx = unsignedTx.getTransaction()\n        const outsNft = rawTx.getOuts()\n        const insNft = rawTx.getIns()\n\n        // TODO: This is a hackish way of doing this, need methods in avalanche.js\n        //@ts-ignore\n        rawTx.outs = outsNft.concat(outs)\n        //@ts-ignore\n        rawTx.ins = insNft.concat(ins)\n    } else {\n        const baseTx: BaseTx = new BaseTx(networkId, chainId, outs, ins, memo)\n        unsignedTx = new AVMUnsignedTx(baseTx)\n    }\n    return unsignedTx\n}\n\nexport async function buildCreateNftFamilyTx(\n    name: string,\n    symbol: string,\n    groupNum: number,\n    fromAddrs: string[],\n    minterAddr: string,\n    changeAddr: string,\n    utxoSet: UTXOSet\n) {\n    const fromAddresses = fromAddrs\n    const changeAddress = changeAddr\n    const minterAddress = minterAddr\n\n    const minterSets: MinterSet[] = []\n\n    // Create the groups\n    for (let i = 0; i < groupNum; i++) {\n        const minterSet: MinterSet = new MinterSet(1, [minterAddress])\n        minterSets.push(minterSet)\n    }\n\n    const unsignedTx: AVMUnsignedTx = await avm.buildCreateNFTAssetTx(\n        utxoSet,\n        fromAddresses,\n        [changeAddress],\n        minterSets,\n        name,\n        symbol\n    )\n    return unsignedTx\n}\n\nexport async function buildMintNftTx(\n    mintUtxo: AVMUTXO,\n    payload: PayloadBase,\n    quantity: number,\n    ownerAddress: string,\n    changeAddress: string,\n    fromAddresses: string[],\n    utxoSet: UTXOSet\n): Promise<AVMUnsignedTx> {\n    const addrBuf = bintools.parseAddress(ownerAddress, 'X')\n    const owners = []\n\n    const sourceAddresses = fromAddresses\n\n    for (let i = 0; i < quantity; i++) {\n        const owner = new OutputOwners([addrBuf])\n        owners.push(owner)\n    }\n\n    const groupID = (mintUtxo.getOutput() as NFTMintOutput).getGroupID()\n\n    const mintTx = await avm.buildCreateNFTMintTx(\n        utxoSet,\n        owners,\n        sourceAddresses,\n        [changeAddress],\n        mintUtxo.getUTXOID(),\n        groupID,\n        payload\n    )\n    return mintTx\n}\n\nexport async function buildEvmTransferNativeTx(\n    from: string,\n    to: string,\n    amount: BN, // in wei\n    gasPrice: BN,\n    gasLimit: number\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    const tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            to: to,\n            value: amount,\n            data: '0x',\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport async function buildEvmTransferErc20Tx(\n    from: string,\n    to: string,\n    amount: BN, // in wei\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    const tokenTx = token.createTransferTx(to, amount)\n\n    const tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            value: '0x0',\n            to: token.data.address,\n            data: tokenTx.encodeABI(),\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport async function buildEvmTransferErc721Tx(\n    from: string,\n    to: string,\n    gasPrice: BN,\n    gasLimit: number,\n    token: ERC721Token,\n    tokenId: string\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    const tokenTx = token.createTransferTx(from, to, tokenId)\n\n    const tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            value: '0x0',\n            to: token.data.address,\n            data: tokenTx.encodeABI(),\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport enum AvmTxNameEnum {\n    'Transaction' = AVMConstants.BASETX,\n    'Mint' = AVMConstants.CREATEASSETTX,\n    'Operation' = AVMConstants.OPERATIONTX,\n    'Import' = AVMConstants.IMPORTTX,\n    'Export' = AVMConstants.EXPORTTX,\n}\n\nexport enum PlatfromTxNameEnum {\n    'Transaction' = PlatformVMConstants.BASETX,\n    'Add Validator' = PlatformVMConstants.ADDVALIDATORTX,\n    'Add Delegator' = PlatformVMConstants.ADDDELEGATORTX,\n    'Import' = PlatformVMConstants.IMPORTTX,\n    'Export' = PlatformVMConstants.EXPORTTX,\n    'Add Subnet Validator' = PlatformVMConstants.ADDSUBNETVALIDATORTX,\n    'Create Chain' = PlatformVMConstants.CREATECHAINTX,\n    'Create Subnet' = PlatformVMConstants.CREATESUBNETTX,\n    'Advance Time' = PlatformVMConstants.ADVANCETIMETX,\n    'Reward Validator' = PlatformVMConstants.REWARDVALIDATORTX,\n}\n\n// TODO: create asset transactions\nexport enum ParseableAvmTxEnum {\n    'Transaction' = AVMConstants.BASETX,\n    'Import' = AVMConstants.IMPORTTX,\n    'Export' = AVMConstants.EXPORTTX,\n}\n\nexport enum ParseablePlatformEnum {\n    'Transaction' = PlatformVMConstants.BASETX,\n    'Add Validator' = PlatformVMConstants.ADDVALIDATORTX,\n    'Add Delegator' = PlatformVMConstants.ADDDELEGATORTX,\n    'Import' = PlatformVMConstants.IMPORTTX,\n    'Export' = PlatformVMConstants.EXPORTTX,\n}\n\nexport enum ParseableEvmTxEnum {\n    'Import' = EVMConstants.IMPORTTX,\n    'Export' = EVMConstants.EXPORTTX,\n}\n","import { Buffer } from 'buffer/'\nimport createHash from 'create-hash'\n\n/**\n * @ignore\n */\n\n/**\n * Helper utility for encryption and password hashing, browser-safe.\n * Encryption is using AES-GCM with a random public nonce.\n */\nexport default class CryptoHelpers {\n    protected ivSize: number = 12\n\n    protected saltSize: number = 16\n\n    protected tagLength: number = 128\n\n    protected aesLength: number = 256\n\n    public keygenIterations: number = 200000 //3.0, 2.0 uses 100000\n\n    /**\n     * Internal-intended function for cleaning passwords.\n     *\n     * @param password\n     * @param salt\n     */\n    _pwcleaner(password: string, slt: Buffer): Buffer {\n        const pw: Buffer = Buffer.from(password, 'utf8')\n        return this.sha256(Buffer.concat([pw, slt]))\n    }\n    /**\n     * Internal-intended function for producing an intermediate key.\n     *\n     * @param pwkey\n     */\n\n    async _keyMaterial(pwkey: Buffer): Promise<CryptoKey> {\n        return window.crypto.subtle.importKey(\n            'raw',\n            new Uint8Array(pwkey),\n            { name: 'PBKDF2' },\n            false,\n            ['deriveKey']\n        )\n    }\n\n    /**\n     * Internal-intended function for turning an intermediate key into a salted key.\n     *\n     * @param keyMaterial\n     * @param salt\n     */\n    async _deriveKey(keyMaterial: CryptoKey, salt: Buffer): Promise<CryptoKey> {\n        return window.crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt,\n                iterations: this.keygenIterations,\n                hash: 'SHA-256',\n            },\n            keyMaterial,\n            { name: 'AES-GCM', length: this.aesLength },\n            false,\n            ['encrypt', 'decrypt']\n        )\n    }\n\n    /**\n     * A SHA256 helper function.\n     *\n     * @param message The message to hash\n     *\n     * @returns A {@link https://github.com/feross/buffer|Buffer} containing the SHA256 hash of the message\n     */\n    sha256(message: string | Buffer): Buffer {\n        let buff: Buffer\n        if (typeof message === 'string') {\n            buff = Buffer.from(message, 'utf8')\n        } else {\n            buff = Buffer.from(message)\n        }\n        return Buffer.from(createHash('sha256').update(buff).digest()) // ensures correct Buffer class is used\n    }\n\n    /**\n     * Generates a randomized {@link https://github.com/feross/buffer|Buffer} to be used as a salt\n     */\n    makeSalt(): Buffer {\n        const salt = Buffer.alloc(this.saltSize)\n        window.crypto.getRandomValues(salt)\n        return salt\n    }\n\n    /**\n     * Produces a password-safe hash.\n     *\n     * @param password A string for the password\n     * @param salt An optional {@link https://github.com/feross/buffer|Buffer} containing a salt used in the password hash\n     *\n     * @returns An object containing the \"salt\" and the \"hash\" produced by this function, both as {@link https://github.com/feross/buffer|Buffer}.\n     */\n    async pwhash(password: string, salt: Buffer): Promise<{ salt: Buffer; hash: Buffer }> {\n        let slt: Buffer\n        if (salt instanceof Buffer) {\n            slt = salt\n            // @ts-ignore\n        } else if (salt instanceof Uint8Array && process.env.NODE_ENV === 'test') {\n            slt = salt\n        } else {\n            slt = this.makeSalt()\n        }\n\n        const hash: Buffer = this._pwcleaner(password, this._pwcleaner(password, slt))\n        return { salt: slt, hash }\n    }\n\n    /**\n     * Encrypts plaintext with the provided password using AES-GCM.\n     *\n     * @param password A string for the password\n     * @param plaintext The plaintext to encrypt\n     * @param salt An optional {@link https://github.com/feross/buffer|Buffer} for the salt to use in the encryption process\n     *\n     * @returns An object containing the \"salt\", \"iv\", and \"ciphertext\", all as {@link https://github.com/feross/buffer|Buffer}.\n     */\n    async encrypt(\n        password: string,\n        plaintext: Buffer | string,\n        salt: Buffer | undefined = undefined\n    ): Promise<{ salt: Buffer; iv: Buffer; ciphertext: Buffer }> {\n        let slt: Buffer\n        if (typeof salt !== 'undefined' && salt instanceof Buffer) {\n            slt = salt\n        } else {\n            slt = this.makeSalt()\n        }\n\n        let pt: Buffer\n        if (typeof plaintext !== 'undefined' && plaintext instanceof Buffer) {\n            pt = plaintext\n        } else {\n            pt = Buffer.from(plaintext, 'utf8')\n        }\n        const pwkey: Buffer = this._pwcleaner(password, slt)\n        const keyMaterial: CryptoKey = await this._keyMaterial(pwkey)\n        const pkey: CryptoKey = await this._deriveKey(keyMaterial, slt)\n        const iv: Buffer = Buffer.from(window.crypto.getRandomValues(new Uint8Array(this.ivSize)))\n\n        const ciphertext: Buffer = Buffer.from(\n            await window.crypto.subtle.encrypt(\n                {\n                    name: 'AES-GCM',\n                    iv,\n                    additionalData: slt,\n                    tagLength: this.tagLength,\n                },\n                pkey,\n                pt\n            )\n        )\n\n        return {\n            salt: slt,\n            iv,\n            ciphertext,\n        }\n    }\n\n    /**\n     * Decrypts ciphertext with the provided password, iv, and salt.\n     *\n     * @param password A string for the password\n     * @param ciphertext A {@link https://github.com/feross/buffer|Buffer} for the ciphertext\n     * @param salt A {@link https://github.com/feross/buffer|Buffer} for the salt\n     * @param iv A {@link https://github.com/feross/buffer|Buffer} for the iv\n     */\n    async decrypt(password: string, ciphertext: Buffer, salt: Buffer, iv: Buffer): Promise<Buffer> {\n        const pwkey: Buffer = this._pwcleaner(password, salt)\n        const keyMaterial: CryptoKey = await this._keyMaterial(pwkey)\n        const pkey: CryptoKey = await this._deriveKey(keyMaterial, salt)\n\n        const pt: Buffer = Buffer.from(\n            await window.crypto.subtle.decrypt(\n                {\n                    name: 'AES-GCM',\n                    iv, // The initialization vector you used to encrypt\n                    additionalData: salt, // The addtionalData you used to encrypt (if any)\n                    tagLength: 128, // The tagLength you used to encrypt (if any)\n                },\n                pkey, // from generateKey or importKey above\n                ciphertext // ArrayBuffer of the data\n            )\n        )\n        return pt\n    }\n\n    constructor() {}\n}\n","// Functions to manage import/export of keystore files\nimport {\n    AllKeyFileDecryptedTypes,\n    AllKeyFileTypes,\n    KeyFileDecryptedV2,\n    KeyFileDecryptedV3,\n    KeyFileDecryptedV4,\n    KeyFileDecryptedV5,\n    KeyFileDecryptedV6,\n    KeyFileKeyDecryptedV2,\n    KeyFileKeyDecryptedV3,\n    KeyFileKeyDecryptedV4,\n    KeyFileKeyDecryptedV5,\n    KeyFileKeyDecryptedV6,\n    KeyFileKeyV2,\n    KeyFileKeyV3,\n    KeyFileKeyV4,\n    KeyFileKeyV5,\n    KeyFileKeyV6,\n    KeyFileV2,\n    KeyFileV3,\n    KeyFileV4,\n    KeyFileV5,\n    KeyFileV6,\n    KeystoreFileKeyType,\n} from './IKeystore'\nimport { avm, bintools } from '@/AVA'\nimport { Buffer } from 'buffer/'\nimport MnemonicWallet from '@/js/wallets/MnemonicWallet'\nimport Crypto from '@/js/Crypto'\nimport { SingletonWallet } from '@/js/wallets/SingletonWallet'\nimport { AccessWalletMultipleInput } from '@/store/types'\nimport { keyToKeypair } from '@/helpers/helper'\nimport * as bip39 from 'bip39'\nimport { Buffer as AjsBuffer } from 'avalanche'\n\nconst cryptoHelpers = new Crypto()\n\nconst KEYSTORE_VERSION: string = '6.0'\n\nconst ITERATIONS_V2 = 100000\nconst ITERATIONS_V3 = 200000 // and any version above\n\nconst SUPPORTED_VERSION = ['2.0', '3.0', '4.0', '5.0', '6.0']\n\ninterface IHash {\n    salt: Buffer\n    hash: Buffer\n}\n\ninterface PKCrypt {\n    salt: Buffer\n    iv: Buffer\n    ciphertext: Buffer\n}\n\nasync function readV2(data: KeyFileV2, pass: string) {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V2\n\n    const salt: Buffer = bintools.cb58Decode(data.salt)\n    const pass_hash: string = data.pass_hash\n\n    const checkHash: Buffer = await cryptoHelpers._pwcleaner(pass, salt)\n    const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash))\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    const keys: KeyFileKeyV2[] = data.keys\n    const keysDecrypt: KeyFileKeyDecryptedV2[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        const key_data: KeyFileKeyV2 = keys[i]\n\n        const key: Buffer = bintools.cb58Decode(key_data.key)\n        const nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        const key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt))\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\nasync function readV3(data: KeyFileV3, pass: string) {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    const salt: Buffer = bintools.cb58Decode(data.salt)\n    const pass_hash: string = data.pass_hash\n\n    const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash))\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    const keys: KeyFileKeyV3[] = data.keys\n    const keysDecrypt: KeyFileKeyDecryptedV3[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        const key_data: KeyFileKeyV3 = keys[i]\n\n        const key: Buffer = bintools.cb58Decode(key_data.key)\n        const nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        const key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt))\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\nasync function readV4(data: KeyFileV4, pass: string): Promise<KeyFileDecryptedV5> {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    const salt: Buffer = bintools.cb58Decode(data.salt)\n    const pass_hash: string = data.pass_hash\n\n    const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash))\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    const keys: KeyFileKeyV4[] = data.keys\n    const keysDecrypt: KeyFileKeyDecryptedV4[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        const key_data: KeyFileKeyV4 = keys[i]\n\n        const key: Buffer = bintools.cb58Decode(key_data.key)\n        const nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        const key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        const key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt))\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readV5(data: KeyFileV5, pass: string): Promise<KeyFileDecryptedV5> {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    const salt: Buffer = bintools.cb58Decode(data.salt)\n    const pass_hash = data.pass_hash\n\n    const checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    const checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash))\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    const keys: KeyFileKeyV5[] = data.keys\n    const keysDecrypt: KeyFileKeyDecryptedV5[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        const key_data: KeyFileKeyV5 = keys[i]\n\n        const key: Buffer = bintools.cb58Decode(key_data.key)\n        const nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        const key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        const key_string = key_decrypt.toString()\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readV6(data: KeyFileV6, pass: string): Promise<KeyFileDecryptedV6> {\n    const version: string = data.version\n    const activeIndex = data.activeIndex\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    const salt: Buffer = bintools.cb58Decode(data.salt)\n\n    const keys: KeyFileKeyV6[] = data.keys\n    const keysDecrypt: KeyFileKeyDecryptedV6[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        const key_data: KeyFileKeyV6 = keys[i]\n\n        const key: Buffer = bintools.cb58Decode(key_data.key)\n        const type: KeystoreFileKeyType = key_data.type\n        const nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer\n        try {\n            key_decrypt = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        } catch (e) {\n            throw 'INVALID_PASS'\n        }\n\n        const key_string = key_decrypt.toString()\n\n        keysDecrypt.push({\n            key: key_string,\n            type: type,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: activeIndex || 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readKeyFile(data: AllKeyFileTypes, pass: string): Promise<AllKeyFileDecryptedTypes> {\n    switch (data.version) {\n        case '6.0':\n            return await readV6(data as KeyFileV6, pass)\n        case '5.0':\n            return await readV5(data as KeyFileV5, pass)\n        case '4.0':\n            return await readV4(data as KeyFileV4, pass)\n        case '3.0':\n            return await readV3(data as KeyFileV3, pass)\n        case '2.0':\n            return await readV2(data as KeyFileV2, pass)\n        default:\n            throw 'INVALID_VERSION'\n    }\n}\n\nfunction extractKeysV2(\n    file: KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4\n): AccessWalletMultipleInput[] {\n    const chainID = avm.getBlockchainAlias()\n    const keys = (file as KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4).keys\n\n    return keys.map((key) => {\n        // Private keys from the keystore file do not have the PrivateKey- prefix\n        const pk = 'PrivateKey-' + key.key\n        const keypair = keyToKeypair(pk, chainID)\n\n        const keyBuf = keypair.getPrivateKey()\n        const keyHex: string = keyBuf.toString('hex')\n        const paddedKeyHex = keyHex.padStart(64, '0')\n        const mnemonic: string = bip39.entropyToMnemonic(paddedKeyHex)\n\n        return {\n            key: mnemonic,\n            type: 'mnemonic',\n        }\n    })\n}\n\nfunction extractKeysV5(file: KeyFileDecryptedV5): AccessWalletMultipleInput[] {\n    return file.keys.map((key) => ({\n        key: key.key,\n        type: 'mnemonic',\n    }))\n}\n\nfunction extractKeysV6(file: KeyFileDecryptedV6): AccessWalletMultipleInput[] {\n    return file.keys.map((key) => ({\n        type: key.type,\n        key: key.key,\n    }))\n}\n\nfunction extractKeysFromDecryptedFile(file: AllKeyFileDecryptedTypes): AccessWalletMultipleInput[] {\n    switch (file.version) {\n        case '6.0':\n            return extractKeysV6(file as KeyFileDecryptedV6)\n        case '5.0':\n            return extractKeysV5(file as KeyFileDecryptedV5)\n        case '4.0':\n            return extractKeysV2(file as KeyFileDecryptedV4)\n        case '3.0':\n            return extractKeysV2(file as KeyFileDecryptedV3)\n        case '2.0':\n            return extractKeysV2(file as KeyFileDecryptedV2)\n        default:\n            throw 'INVALID_VERSION'\n    }\n}\n\n// Given an array of wallets and a password, return an encrypted JSON object that is the keystore file\nasync function makeKeyfile(\n    wallets: (MnemonicWallet | SingletonWallet)[],\n    pass: string,\n    activeIndex: number\n): Promise<KeyFileV6> {\n    // 3.0 and above uses 200,000\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    const salt: Buffer = await cryptoHelpers.makeSalt()\n\n    const keys: KeyFileKeyV6[] = []\n\n    for (let i: number = 0; i < wallets.length; i++) {\n        const wallet = wallets[i]\n        let key\n        let type: KeystoreFileKeyType\n        if (wallet.type === 'singleton') {\n            key = (wallet as SingletonWallet).key\n            type = 'singleton'\n        } else {\n            key = (wallet as MnemonicWallet).getMnemonic()\n            type = 'mnemonic'\n        }\n        const pk_crypt: PKCrypt = await cryptoHelpers.encrypt(pass, key, salt)\n\n        const key_data: KeyFileKeyV6 = {\n            key: bintools.cb58Encode(AjsBuffer.from(pk_crypt.ciphertext)),\n            iv: bintools.cb58Encode(AjsBuffer.from(pk_crypt.iv)),\n            type: type,\n        }\n        keys.push(key_data)\n    }\n\n    const file_data: KeyFileV6 = {\n        version: KEYSTORE_VERSION,\n        salt: bintools.cb58Encode(AjsBuffer.from(salt)),\n        activeIndex,\n        keys: keys,\n    }\n    return file_data\n}\n\nexport { readKeyFile, makeKeyfile, KEYSTORE_VERSION, extractKeysFromDecryptedFile }\n","import axios, { AxiosInstance } from 'axios'\nimport { ITransactionData } from './store/modules/history/types'\n\n// Doesn't really matter what we set, it will change\nconst api_url: string = '/api'\nconst explorer_api: AxiosInstance = axios.create({\n    baseURL: api_url,\n    withCredentials: false,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n})\n\nasync function getAddressHistory(\n    addrs: string[],\n    limit = 20,\n    chainID: string,\n    endTime?: string\n): Promise<ITransactionData[]> {\n    const ADDR_SIZE = 1024\n    const selection = addrs.slice(0, ADDR_SIZE)\n    const remaining = addrs.slice(ADDR_SIZE)\n\n    const addrsRaw = selection.map((addr) => {\n        return addr.split('-')[1]\n    })\n\n    const rootUrl = 'v2/transactions'\n\n    const req = {\n        address: addrsRaw,\n        sort: ['timestamp-desc'],\n        disableCount: ['1'],\n        chainID: [chainID],\n        disableGenesis: ['false'],\n    }\n\n    if (limit > 0) {\n        //@ts-ignore\n        req.limit = [limit.toString()]\n    }\n\n    if (endTime) {\n        console.log('Setting endtime')\n        //@ts-ignore\n        req.endTime = [endTime]\n    }\n\n    const res = await explorer_api.post(rootUrl, req)\n    let txs = res.data.transactions\n    const next: string | undefined = res.data.next\n\n    if (txs === null) txs = []\n\n    // If we need to fetch more for this address\n    if (next && !limit) {\n        const endTime = next.split('&')[0].split('=')[1]\n        const nextRes = await getAddressHistory(selection, limit, chainID, endTime)\n        txs.push(...nextRes)\n    }\n\n    // If there are addresses left, fetch them too\n    if (remaining.length > 0) {\n        const nextRes = await getAddressHistory(remaining, limit, chainID)\n        txs.push(...nextRes)\n    }\n\n    return txs\n}\n\nasync function isAddressUsedX(addr: string) {\n    const addrRaw = addr.split('-')[1]\n    const url = `/x/transactions?address=${addrRaw}&limit=1&disableCount=1`\n    try {\n        const res = await explorer_api.get(url)\n        // console.log(res);\n        if (res.data.transactions.length > 0) return true\n        else return false\n    } catch (e) {\n        throw e\n    }\n}\n\nasync function getAddressDetailX(addr: string) {\n    const addrRaw = addr.split('-')[1]\n    const url = `/x/addresses/${addrRaw}`\n\n    try {\n        const res = await explorer_api.get(url)\n        return res.data\n    } catch (e) {\n        throw e\n    }\n}\n\nasync function getAddressChains(addrs: string[]) {\n    // Strip the prefix\n    const rawAddrs = addrs.map((addr) => {\n        return addr.split('-')[1]\n    })\n\n    const urlRoot = `/v2/addressChains`\n\n    const res = await explorer_api.post(urlRoot, {\n        address: rawAddrs,\n        disableCount: ['1'],\n    })\n\n    return res.data.addressChains\n}\n\nexport { explorer_api, getAddressHistory, getAddressDetailX, isAddressUsedX, getAddressChains }\n","import Web3 from 'web3'\n\nimport ERC721Abi from '@openzeppelin/contracts/build/contracts/ERC721.json'\nimport ERC20Abi from '@openzeppelin/contracts/build/contracts/ERC20.json'\n\nconst abiDecoder = require('abi-decoder') // NodeJS\n\nabiDecoder.addABI(ERC721Abi.abi)\nabiDecoder.addABI(ERC20Abi.abi)\n\nconst rpcUrl = `https://dijets.ukwest.cloudapp.azure.com:443/ext/bc/C/rpc`\n\nconst web3 = new Web3(rpcUrl)\n\nexport { web3, abiDecoder }\n","const axios = require('axios')\n\nconst COIN_ID = 'havven'\nconst COINGECKO_URL = 'https://api.coingecko.com/api/v3/simple/price?ids=havven&vs_currencies=usd'\n\nconst coingeckoApi = axios.create({\n    baseURL: 'https://api.coingecko.com/api/v3',\n    timeout: 10000,\n})\n\nexport async function getDjtxPriceUSD(): Promise<number> {\n    const res = await axios.get(COINGECKO_URL)\n    return res.data['havven']['usd']\n}\n\nlet priceHistory: [number, number][] = []\nasync function getPriceHistory() {\n    const res = await coingeckoApi.get(`/coins/${COIN_ID}/market_chart`, {\n        params: {\n            vs_currency: 'usd',\n            days: 'max',\n            interval: 'daily',\n        },\n    })\n\n    priceHistory = res.data.prices\n}\n\n/**\n * Round the UNIX time in ms and search the previously fetched price points\n * @param time\n */\nexport function getPriceAtUnixTime(time: number): number | undefined {\n    const remainder = time % (24 * 60 * 60 * 1000)\n    const dayTimestamp = time - remainder\n\n    const pricePair = priceHistory.find((value) => {\n        return value[0] == dayTimestamp\n    })\n\n    if (!pricePair) return undefined\n    return pricePair[1]\n}\n\ngetPriceHistory()\n","import {\n    KeyChain as AVMKeyChain,\n    KeyPair as AVMKeyPair,\n    UTXOSet as AVMUTXOSet,\n} from 'avalanche/dist/apis/avm'\n\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm'\nimport { getPreferredHRP } from 'avalanche/dist/utils'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport HDKey from 'hdkey'\nimport { Buffer } from 'avalanche'\nimport {\n    KeyChain as PlatformVMKeyChain,\n    KeyPair as PlatformVMKeyPair,\n} from 'avalanche/dist/apis/platformvm'\nimport store from '@/store'\n\nimport { getAddressChains } from '@/explorer_api'\nimport { AvaNetwork } from '@/js/AvaNetwork'\nimport { ChainAlias } from './wallets/types'\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from '@/helpers/utxo_helper'\nimport { updateFilterAddresses } from '../providers'\n\nconst INDEX_RANGE: number = 20 // a gap of at least 20 indexes is needed to claim an index unused\n\nconst SCAN_SIZE: number = 100 // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE // How many items are actually scanned\nclass HdHelper {\n    chainId: ChainAlias\n    keyChain: AVMKeyChain | PlatformVMKeyChain\n    keyCache: {\n        [index: number]: AVMKeyPair | PlatformVMKeyPair\n    }\n    addressCache: {\n        [index: number]: string\n    }\n    hdCache: {\n        [index: number]: HDKey\n    }\n    changePath: string\n    masterKey: HDKey\n    hdIndex: number\n    utxoSet: AVMUTXOSet | PlatformUTXOSet\n    isPublic: boolean\n    isFetchUtxo: boolean // true if updating balance\n    isInit: boolean // true if HD index is found\n\n    constructor(\n        changePath: string,\n        masterKey: HDKey,\n        chainId: ChainAlias = 'X',\n        isPublic: boolean = false\n    ) {\n        this.changePath = changePath\n        this.isFetchUtxo = false\n        this.isInit = false\n\n        this.chainId = chainId\n        const hrp = getPreferredHRP(ava.getNetworkID())\n        if (chainId === 'X') {\n            this.keyChain = new AVMKeyChain(hrp, chainId)\n            this.utxoSet = new AVMUTXOSet()\n        } else {\n            this.keyChain = new PlatformVMKeyChain(hrp, chainId)\n            this.utxoSet = new PlatformUTXOSet()\n        }\n\n        this.keyCache = {}\n        this.addressCache = {}\n        this.hdCache = {}\n        this.masterKey = masterKey\n        this.hdIndex = 0\n        this.isPublic = isPublic\n        // this.oninit()\n    }\n\n    async oninit() {\n        await this.findHdIndex()\n    }\n\n    // When the wallet connects to a different network\n    // Clear internal data and scan again\n    async onNetworkChange() {\n        this.clearCache()\n        this.isInit = false\n        const hrp = getPreferredHRP(ava.getNetworkID())\n        if (this.chainId === 'X') {\n            this.keyChain = new AVMKeyChain(hrp, this.chainId)\n            this.utxoSet = new AVMUTXOSet()\n        } else {\n            this.keyChain = new PlatformVMKeyChain(hrp, this.chainId)\n            this.utxoSet = new PlatformUTXOSet()\n        }\n        this.hdIndex = 0\n        await this.oninit()\n    }\n\n    // Increments the hd index by one and adds the key\n    // returns the new keypair\n    incrementIndex(): number {\n        const newIndex: number = this.hdIndex + 1\n\n        if (!this.isPublic) {\n            if (this.chainId === 'X') {\n                const keychain = this.keyChain as AVMKeyChain\n                const newKey = this.getKeyForIndex(newIndex) as AVMKeyPair\n                keychain.addKey(newKey)\n            } else {\n                const keychain = this.keyChain as PlatformVMKeyChain\n                const newKey = this.getKeyForIndex(newIndex) as PlatformVMKeyPair\n                keychain.addKey(newKey)\n            }\n        }\n\n        this.hdIndex = newIndex\n\n        // Update websocket addresses with the new one\n        updateFilterAddresses()\n\n        return newIndex\n    }\n\n    async findHdIndex() {\n        // Check if explorer is available\n\n        // @ts-ignore\n        const network: AvaNetwork = store.state.Network.selectedNetwork\n        const explorerUrl = network.explorerUrl\n\n        if (explorerUrl) {\n            this.hdIndex = await this.findAvailableIndexExplorer()\n        } else {\n            this.hdIndex = await this.findAvailableIndexNode()\n        }\n\n        if (!this.isPublic) {\n            this.updateKeychain()\n        }\n        this.isInit = true\n    }\n\n    // Fetches the utxos for the current keychain\n    // and increments the index if last index has a utxo\n    async updateUtxos(): Promise<AVMUTXOSet | PlatformUTXOSet> {\n        this.isFetchUtxo = true\n\n        if (!this.isInit) {\n            console.error('HD Index not found yet.')\n        }\n\n        const addrs: string[] = this.getAllDerivedAddresses()\n        let result: AVMUTXOSet | PlatformUTXOSet\n\n        if (this.chainId === 'X') {\n            result = await avmGetAllUTXOs(addrs)\n        } else {\n            result = await platformGetAllUTXOs(addrs)\n        }\n        this.utxoSet = result // we can use local copy of utxos as cache for some functions\n\n        // If the hd index is full, increment\n        const currentAddr = this.getCurrentAddress()\n        const currentAddrBuf = bintools.parseAddress(currentAddr, this.chainId)\n        const currentUtxos = result.getUTXOIDs([currentAddrBuf])\n\n        if (currentUtxos.length > 0) {\n            this.incrementIndex()\n        }\n        this.isFetchUtxo = false\n        return result\n    }\n\n    // Returns more addresses than the current index\n    getExtendedAddresses() {\n        const hdIndex = this.hdIndex\n        return this.getAllDerivedAddresses(hdIndex + INDEX_RANGE)\n    }\n\n    // Not used?\n    getUtxos(): AVMUTXOSet | PlatformUTXOSet {\n        return this.utxoSet\n    }\n\n    // Updates the helper keychain to contain keys upto the HD Index\n    updateKeychain(): AVMKeyChain | PlatformVMKeyChain {\n        const hrp = getPreferredHRP(ava.getNetworkID())\n        let keychain: AVMKeyChain | PlatformVMKeyChain\n\n        if (this.chainId === 'X') {\n            keychain = new AVMKeyChain(hrp, this.chainId)\n        } else {\n            keychain = new PlatformVMKeyChain(hrp, this.chainId)\n        }\n\n        for (let i: number = 0; i <= this.hdIndex; i++) {\n            let key: AVMKeyPair | PlatformVMKeyPair\n            if (this.chainId === 'X') {\n                key = this.getKeyForIndex(i) as AVMKeyPair\n                ;(keychain as AVMKeyChain).addKey(key)\n            } else {\n                key = this.getKeyForIndex(i) as PlatformVMKeyPair\n                ;(keychain as PlatformVMKeyChain).addKey(key)\n            }\n        }\n        this.keyChain = keychain\n        return keychain\n    }\n\n    getKeychain() {\n        return this.keyChain\n    }\n\n    // Returns all key pairs up to hd index\n    getAllDerivedKeys(upTo = this.hdIndex): AVMKeyPair[] | PlatformVMKeyPair[] {\n        const set: AVMKeyPair[] | PlatformVMKeyPair[] = []\n        for (let i = 0; i <= upTo; i++) {\n            if (this.chainId === 'X') {\n                const key = this.getKeyForIndex(i) as AVMKeyPair\n                ;(set as AVMKeyPair[]).push(key)\n            } else {\n                const key = this.getKeyForIndex(i) as PlatformVMKeyPair\n                ;(set as PlatformVMKeyPair[]).push(key)\n            }\n        }\n        return set\n    }\n\n    getAllDerivedAddresses(upTo = this.hdIndex, start = 0): string[] {\n        const res = []\n        for (let i = start; i <= upTo; i++) {\n            const addr = this.getAddressForIndex(i)\n            res.push(addr)\n        }\n        return res\n    }\n\n    clearCache() {\n        this.keyCache = {}\n        this.addressCache = {}\n    }\n\n    // Scans the address space of this hd path and finds the last used index using the\n    // explorer API.\n    async findAvailableIndexExplorer(startIndex = 0): Promise<number> {\n        const upTo = 512\n\n        const addrs = this.getAllDerivedAddresses(startIndex + upTo, startIndex)\n        const addrChains = await getAddressChains(addrs)\n\n        let chainID\n        if (this.chainId === 'X') {\n            chainID = avm.getBlockchainID()\n        } else {\n            chainID = pChain.getBlockchainID()\n        }\n\n        for (let i = 0; i < addrs.length - INDEX_RANGE; i++) {\n            let gapSize: number = 0\n\n            for (let n = 0; n < INDEX_RANGE; n++) {\n                const scanIndex = i + n\n                const scanAddr = addrs[scanIndex]\n\n                const rawAddr = scanAddr.split('-')[1]\n                const chains: string[] = addrChains[rawAddr]\n                if (!chains) {\n                    // If doesnt exist on any chain\n                    gapSize++\n                } else if (!chains.includes(chainID)) {\n                    // If doesnt exist on this chain\n                    gapSize++\n                } else {\n                    i = i + n\n                    break\n                }\n            }\n\n            // If the gap is reached return the index\n            if (gapSize === INDEX_RANGE) {\n                return startIndex + i\n            }\n        }\n\n        return await this.findAvailableIndexExplorer(startIndex + (upTo - INDEX_RANGE))\n    }\n\n    // Uses the node to find last used HD index\n    // Only used when there is no explorer API available\n    async findAvailableIndexNode(start: number = 0): Promise<number> {\n        const addrs: string[] = []\n\n        // Get keys for indexes start to start+scan_size\n        for (let i: number = start; i < start + SCAN_SIZE; i++) {\n            const address = this.getAddressForIndex(i)\n            addrs.push(address)\n        }\n\n        let utxoSet\n\n        if (this.chainId === 'X') {\n            utxoSet = (await avm.getUTXOs(addrs)).utxos\n        } else {\n            utxoSet = (await pChain.getUTXOs(addrs)).utxos\n        }\n\n        // Scan UTXOs of these indexes and try to find a gap of INDEX_RANGE\n        for (let i: number = 0; i < addrs.length - INDEX_RANGE; i++) {\n            let gapSize: number = 0\n            // console.log(`Scan index: ${this.chainId} ${this.changePath}/${i+start}`);\n            for (let n: number = 0; n < INDEX_RANGE; n++) {\n                const scanIndex: number = i + n\n                const addr: string = addrs[scanIndex]\n                const addrBuf = bintools.parseAddress(addr, this.chainId)\n                const addrUTXOs: string[] = utxoSet.getUTXOIDs([addrBuf])\n                if (addrUTXOs.length === 0) {\n                    gapSize++\n                } else {\n                    // Potential improvement\n                    i = i + n\n                    break\n                }\n            }\n\n            // If we found a gap of 20, we can return the last fullIndex+1\n            if (gapSize === INDEX_RANGE) {\n                const targetIndex = start + i\n                return targetIndex\n            }\n        }\n        return await this.findAvailableIndexNode(start + SCAN_RANGE)\n    }\n\n    getFirstAvailableIndex(): number {\n        for (let i = 0; i < this.hdIndex; i++) {\n            const addr = this.getAddressForIndex(i)\n            const addrBuf = bintools.parseAddress(addr, this.chainId)\n            const utxoIds = this.utxoSet.getUTXOIDs([addrBuf])\n            if (utxoIds.length === 0) {\n                return i\n            }\n        }\n\n        return 0\n    }\n\n    // Returns the key of the first index that has no utxos\n    getFirstAvailableAddress(): string {\n        const idx = this.getFirstAvailableIndex()\n        return this.getAddressForIndex(idx)\n    }\n\n    getCurrentKey(): AVMKeyPair | PlatformVMKeyPair {\n        const index: number = this.hdIndex\n        return this.getKeyForIndex(index)\n    }\n\n    getCurrentAddress(): string {\n        const index = this.hdIndex\n        return this.getAddressForIndex(index)\n    }\n\n    // TODO: Public wallet should never be using this\n    getKeyForIndex(index: number, isPrivate: boolean = true): AVMKeyPair | PlatformVMKeyPair {\n        // If key is cached return that\n        let cacheExternal: AVMKeyPair | PlatformVMKeyPair\n\n        if (this.chainId === 'X') {\n            cacheExternal = this.keyCache[index] as AVMKeyPair\n        } else {\n            cacheExternal = this.keyCache[index] as PlatformVMKeyPair\n        }\n\n        if (cacheExternal) return cacheExternal\n\n        const derivationPath: string = `${this.changePath}/${index.toString()}`\n\n        // Get key from cache, if not generate it\n        let key: HDKey\n        if (this.hdCache[index]) {\n            key = this.hdCache[index]\n        } else {\n            key = this.masterKey.derive(derivationPath) as HDKey\n            this.hdCache[index] = key\n        }\n\n        let pkHex: string\n        if (!this.isPublic) {\n            pkHex = key.privateKey.toString('hex')\n        } else {\n            pkHex = key.publicKey.toString('hex')\n        }\n\n        const pkBuf: Buffer = new Buffer(pkHex, 'hex')\n        const keypair = this.keyChain.importKey(pkBuf)\n\n        // save to cache\n        this.keyCache[index] = keypair\n        return keypair\n    }\n\n    getAddressForIndex(index: number): string {\n        if (this.addressCache[index]) {\n            return this.addressCache[index]\n        }\n\n        const derivationPath: string = `${this.changePath}/${index.toString()}`\n        // let key: HDKey = this.masterKey.derive(derivationPath) as HDKey;\n\n        // Get key from cache, if not generate it\n        let key: HDKey\n        if (this.hdCache[index]) {\n            key = this.hdCache[index]\n        } else {\n            key = this.masterKey.derive(derivationPath) as HDKey\n            this.hdCache[index] = key\n        }\n\n        const pkHex = key.publicKey.toString('hex')\n        const pkBuff = Buffer.from(pkHex, 'hex')\n        const hrp = getPreferredHRP(ava.getNetworkID())\n\n        const chainId = this.chainId\n\n        // No need for PlatformKeypair because addressToString uses chainID to decode\n        const keypair = new AVMKeyPair(hrp, chainId)\n        const addrBuf = AVMKeyPair.addressFromPublicKey(pkBuff)\n        const addr = bintools.addressToString(hrp, chainId, addrBuf)\n\n        this.addressCache[index] = addr\n        return addr\n    }\n\n    // Given an address find the derived index\n    findAddressIndex(addr: string): number | null {\n        const addrs = this.getAllDerivedAddresses()\n        const index = addrs.indexOf(addr)\n\n        if (index < 0) return null\n        return index\n    }\n}\nexport { HdHelper }\n","import { ChainAlias } from '@/js/wallets/types'\nimport { UTXO } from 'avalanche/dist/apis/avm'\n\nimport { BN, Buffer } from 'avalanche'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { ava, avm, bintools, pChain } from '@/AVA'\nimport { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport HDKey from 'hdkey'\nimport { HdHelper } from '@/js/HdHelper'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm/utxos'\nimport { buildCreateNftFamilyTx, buildMintNftTx, buildUnsignedTransaction } from '../TxHelper'\nimport { WalletCore } from '@/js/wallets/WalletCore'\nimport { updateFilterAddresses } from '../../providers'\nimport { digestMessage } from '@/helpers/helper'\n\n// A base class other HD wallets are based on.\n// Mnemonic Wallet and LedgerWallet uses this\n\nabstract class HdWalletCore extends WalletCore {\n    chainId: string\n\n    internalHelper: HdHelper\n    externalHelper: HdHelper\n    platformHelper: HdHelper\n\n    ethHdNode: HDKey\n    protected accountNodeXP: HDKey\n\n    constructor(accountHdKey: HDKey, ethHdNode: HDKey, isPublic = true) {\n        super()\n        this.ethHdNode = ethHdNode\n        this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID()\n        this.externalHelper = new HdHelper('m/0', accountHdKey, undefined, isPublic)\n        this.internalHelper = new HdHelper('m/1', accountHdKey, undefined, isPublic)\n        this.platformHelper = new HdHelper('m/0', accountHdKey, 'P', isPublic)\n        this.accountNodeXP = accountHdKey\n\n        this.externalHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n        this.internalHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n        this.platformHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n    }\n\n    getXpubXP() {\n        return this.accountNodeXP.toJSON().xpub\n    }\n\n    getEvmAddressBech(): string {\n        return bintools.addressToString(\n            ava.getHRP(),\n            'C',\n            // @ts-ignore\n            this.ethHdNode.pubKeyHash\n        )\n    }\n\n    updateAvmUTXOSet(): void {\n        // if (this.isFetchUtxos) return\n        const setExternal = this.externalHelper.utxoSet as AVMUTXOSet\n        const setInternal = this.internalHelper.utxoSet as AVMUTXOSet\n\n        const joined = setInternal.merge(setExternal)\n        this.utxoset = joined\n    }\n\n    getFirstAvailableAddressPlatform(): string {\n        return this.platformHelper.getFirstAvailableAddress()\n    }\n\n    updateFetchState() {\n        this.isFetchUtxos =\n            this.externalHelper.isFetchUtxo ||\n            this.internalHelper.isFetchUtxo ||\n            this.platformHelper.isFetchUtxo\n    }\n\n    updateInitState() {\n        this.isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n\n        if (this.isInit) {\n            updateFilterAddresses()\n        }\n    }\n    // Fetches the utxos\n    async getUTXOs(): Promise<void> {\n        this.updateUTXOsX()\n\n        // platform utxos are updated but not returned by function\n        this.updateUTXOsP()\n\n        return\n    }\n\n    async updateUTXOsX() {\n        this.updateUTXOsExternal()\n        this.updateUTXOsInternal()\n    }\n\n    async updateUTXOsExternal() {\n        const res = await this.externalHelper.updateUtxos()\n        this.updateFetchState()\n        this.updateAvmUTXOSet()\n    }\n\n    async updateUTXOsInternal() {\n        const utxoSet = await this.internalHelper.updateUtxos()\n        this.updateFetchState()\n        this.updateAvmUTXOSet()\n    }\n\n    async updateUTXOsP() {\n        const utxoSet = await this.platformHelper.updateUtxos()\n        this.updateFetchState()\n    }\n\n    getAllDerivedExternalAddresses(): string[] {\n        return this.externalHelper.getAllDerivedAddresses()\n    }\n\n    getDerivedAddresses(): string[] {\n        const internal = this.internalHelper.getAllDerivedAddresses()\n        const external = this.externalHelper.getAllDerivedAddresses()\n        return internal.concat(external)\n    }\n\n    getDerivedAddressesP(): string[] {\n        return this.platformHelper.getAllDerivedAddresses()\n    }\n\n    getAllAddressesX() {\n        return this.getDerivedAddresses()\n    }\n\n    getAllAddressesP() {\n        return this.getDerivedAddressesP()\n    }\n    // Returns addresses to check for history\n    getHistoryAddresses(): string[] {\n        const internalIndex = this.internalHelper.hdIndex\n        // They share the same address space, so whatever has the highest index\n        const externalIndex = Math.max(this.externalHelper.hdIndex, this.platformHelper.hdIndex)\n\n        const internal = this.internalHelper.getAllDerivedAddresses(internalIndex)\n        const external = this.externalHelper.getAllDerivedAddresses(externalIndex)\n        return internal.concat(external)\n    }\n\n    getCurrentAddressAvm(): string {\n        return this.externalHelper.getCurrentAddress()\n    }\n\n    getChangeAddressAvm() {\n        return this.internalHelper.getCurrentAddress()\n    }\n\n    getChangeAddressPlatform() {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getChangePath(chainId?: ChainAlias): string {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.changePath\n            case 'X':\n            default:\n                return this.internalHelper.changePath\n        }\n    }\n\n    getChangeIndex(chainId?: ChainAlias): number {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.hdIndex\n            case 'X':\n            default:\n                return this.internalHelper.hdIndex\n        }\n    }\n\n    getChangeFromIndex(idx?: number, chainId?: ChainAlias): string | null {\n        if (idx === undefined || idx === null) return null\n\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.getAddressForIndex(idx)\n            case 'X':\n            default:\n                return this.internalHelper.getAddressForIndex(idx)\n        }\n    }\n\n    getPlatformRewardAddress(): string {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getCurrentAddressPlatform(): string {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getPlatformUTXOSet() {\n        return this.platformHelper.utxoSet as PlatformUTXOSet\n    }\n\n    getPlatformActiveIndex() {\n        return this.platformHelper.hdIndex\n    }\n\n    getExternalActiveIndex() {\n        return this.externalHelper.hdIndex\n    }\n\n    getBaseAddress() {\n        return this.externalHelper.getAddressForIndex(0)\n    }\n\n    onnetworkchange(): void {\n        this.isInit = false\n        this.stakeAmount = new BN(0)\n\n        this.externalHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n        this.internalHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n        this.platformHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n\n        // TODO: Handle EVM changes\n    }\n\n    async buildUnsignedTransaction(orders: (ITransaction | UTXO)[], addr: string, memo?: Buffer) {\n        const changeAddress = this.getChangeAddressAvm()\n        const derivedAddresses: string[] = this.getDerivedAddresses()\n        const utxoset = this.getUTXOSet()\n\n        return buildUnsignedTransaction(\n            orders,\n            addr,\n            derivedAddresses,\n            utxoset,\n            changeAddress,\n            memo\n        )\n    }\n\n    findExternalAddressIndex(address: string): number | null {\n        // TODO: Look for P addresses too\n        const indexX = this.externalHelper.findAddressIndex(address)\n        const indexP = this.platformHelper.findAddressIndex(address)\n\n        const index = indexX !== null ? indexX : indexP\n\n        if (indexX === null && indexP === null) throw new Error('Address not found.')\n        return index\n    }\n\n    async signMessageByExternalAddress(msgStr: string, address: string) {\n        const index = this.findExternalAddressIndex(address)\n        if (index === null) throw new Error('Address not found.')\n        return await this.signMessageByExternalIndex(msgStr, index)\n    }\n\n    async signMessageByExternalIndex(msgStr: string, index: number): Promise<string> {\n        const digest = digestMessage(msgStr)\n\n        // Convert to the other Buffer and sign\n        const digestHex = digest.toString('hex')\n        const digestBuff = Buffer.from(digestHex, 'hex')\n\n        return await this.signHashByExternalIndex(index, digestBuff)\n    }\n\n    async signMessage(msg: string, address: string) {\n        return await this.signMessageByExternalAddress(msg, address)\n    }\n\n    abstract async signHashByExternalIndex(index: number, hash: Buffer): Promise<string>\n}\nexport { HdWalletCore }\n","// interface IHistoryParsedBaseTx{\n//     sent:\n//     received:\n// }\n\nimport { ITransactionData, UTXO } from '@/store/modules/history/types'\nimport { WalletType } from '@/js/wallets/types'\nimport { BN } from 'avalanche'\nimport { AVMConstants } from 'avalanche/dist/apis/avm'\n\n// Summary item returned for each transaction\nexport interface BaseTxSummary {\n    tokens: {\n        [assetId: string]: BaseTxAssetSummary\n    }\n    collectibles: BaseTxNFTSummary\n}\n\ninterface TokenSummaryResult {\n    [assetID: string]: BaseTxAssetSummary\n}\n\nexport interface BaseTxNFTSummary {\n    received: NFTSummaryResultDict\n    sent: NFTSummaryResultDict\n}\n\ninterface NFTSummaryResultDict {\n    assets: {\n        [assetID: string]: UTXO[]\n    }\n    addresses: string[]\n}\n\n// export interface BaseTxNFTSummary {\n//     sent: UTXO[]\n//     received: UTXO[]\n// }\n\nexport interface BaseTxAssetSummary {\n    amount: BN\n    payload: string | undefined\n    groupNum: number\n    addresses: string[]\n}\n\n// Used with tokens\nfunction addToDict(\n    assetId: string,\n    amount: BN,\n    dict: TokenSummaryResult,\n    utxo: UTXO,\n    addresses: string[]\n) {\n    if (dict[assetId]) {\n        dict[assetId].amount = dict[assetId].amount.add(amount)\n\n        const addrDiff = addresses.filter((addr) => !dict[assetId].addresses.includes(addr))\n        dict[assetId].addresses.push(...addrDiff)\n    } else {\n        dict[assetId] = {\n            amount: amount,\n            payload: utxo.payload,\n            groupNum: utxo.groupID,\n            addresses: addresses,\n        }\n    }\n}\n\nfunction getNFTsSummary(tx: ITransactionData, wallet: WalletType): BaseTxNFTSummary {\n    const nftLoss = getLossNFT(tx, wallet)\n    const nftGain = getGainNFT(tx, wallet)\n    return {\n        sent: nftLoss,\n        received: nftGain,\n    }\n}\n\nfunction getLossNFT(tx: ITransactionData, wallet: WalletType): NFTSummaryResultDict {\n    const walletAddrs = wallet.getHistoryAddresses()\n    const addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    const inputs = tx.inputs || []\n    const outputs = tx.outputs\n\n    const loss: NFTSummaryResultDict = {\n        assets: {},\n        addresses: [],\n    }\n\n    const nfts = inputs.filter((input) => {\n        const type = input.output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    const nftsOuts = outputs.filter((output) => {\n        const type = output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    for (let i = 0; i < nfts.length; i++) {\n        const utxo = nfts[i].output\n        const owners = utxo.addresses\n        const assetID = utxo.assetID\n\n        const intersect = owners.filter((addr) => addrsStripped.includes(addr))\n\n        // Did we lose it?\n        if (intersect.length > 0) {\n            if (loss.assets[assetID]) {\n                loss.assets[assetID].push(utxo)\n            } else {\n                loss.assets[assetID] = [utxo]\n            }\n\n            // Who did we lose it to?\n            for (let n = 0; i < nftsOuts.length; n++) {\n                const nftOut = nftsOuts[n]\n                const doesMatch = nftOut.groupID === utxo.groupID && nftOut.assetID === utxo.assetID\n                const addrNotAdded = nftOut.addresses.filter(\n                    (addr) => !loss.addresses.includes(addr)\n                )\n                if (doesMatch) {\n                    loss.addresses.push(...addrNotAdded)\n                    break\n                }\n            }\n        }\n    }\n\n    return loss\n}\n\nfunction getGainNFT(tx: ITransactionData, wallet: WalletType): NFTSummaryResultDict {\n    const walletAddrs = wallet.getHistoryAddresses()\n    const addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    const inputs = tx.inputs || []\n    const outputs = tx.outputs\n\n    const gain: NFTSummaryResultDict = {\n        assets: {},\n        addresses: [],\n    }\n\n    const nftsIns = inputs.filter((input) => {\n        const type = input.output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    const nftsOuts = outputs.filter((output) => {\n        const type = output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    for (let i = 0; i < nftsOuts.length; i++) {\n        const utxo = nftsOuts[i]\n        const owners = utxo.addresses\n        const assetID = utxo.assetID\n\n        const intersect = owners.filter((addr) => addrsStripped.includes(addr))\n\n        // Did we gain it?\n        if (intersect.length > 0) {\n            if (gain.assets[assetID]) {\n                gain.assets[assetID].push(utxo)\n            } else {\n                gain.assets[assetID] = [utxo]\n            }\n\n            // Who did we gain it from?\n            for (let n = 0; n < nftsIns.length; n++) {\n                const nftIn = nftsIns[n].output\n                const doesMatch = nftIn.groupID === utxo.groupID && nftIn.assetID === utxo.assetID\n                const addrNotAdded = nftIn.addresses.filter(\n                    (addr) => !gain.addresses.includes(addr)\n                )\n                if (doesMatch) {\n                    gain.addresses.push(...addrNotAdded)\n                }\n            }\n        }\n    }\n\n    return gain\n}\n\nfunction getLoss(tx: ITransactionData, wallet: WalletType): TokenSummaryResult {\n    const ins = tx.inputs || []\n    const outs = tx.outputs\n\n    const walletAddrs = wallet.getHistoryAddresses()\n    const addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    const loss: TokenSummaryResult = {}\n\n    if (ins) {\n        for (let i = 0; i < ins.length; i++) {\n            const input = ins[i]\n            const utxo = input.output\n            const outputType = utxo.outputType\n            const isNft = outputType === AVMConstants.NFTXFEROUTPUTID\n\n            if (isNft) continue\n\n            const addrs = utxo.addresses\n\n            const intersect = addrs.filter((addr) => addrsStripped.includes(addr))\n\n            if (intersect.length === 0) continue\n\n            const assetId = utxo.assetID\n            const amount = utxo.amount\n            const amountBN = new BN(amount)\n\n            // Get who received this asset\n            const receivers: string[] = []\n            outs.forEach((utxo) => {\n                if (utxo.assetID === assetId) {\n                    const outAddrs = utxo.addresses\n                    // If not a wallet address and not added to receivers\n                    const targets = outAddrs.filter(\n                        (addr: string) => !addrsStripped.includes(addr) && !receivers.includes(addr)\n                    )\n                    receivers.push(...targets)\n                }\n            })\n\n            addToDict(assetId, amountBN, loss, utxo, receivers)\n        }\n    }\n\n    return loss\n}\n\nfunction getProfit(tx: ITransactionData, wallet: WalletType): TokenSummaryResult {\n    const outs = tx.outputs\n    const ins = tx.inputs || []\n\n    const walletAddrs = wallet.getHistoryAddresses()\n    const addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    const profit: TokenSummaryResult = {}\n\n    if (outs) {\n        for (let i = 0; i < outs.length; i++) {\n            const utxo = outs[i]\n            const outputType = utxo.outputType\n            const isNft = outputType === AVMConstants.NFTXFEROUTPUTID\n\n            // Skip NFTs\n            if (isNft) continue\n\n            const addrs = utxo.addresses\n\n            const intersect = addrs.filter((addr) => addrsStripped.includes(addr))\n\n            if (intersect.length === 0) continue\n\n            const assetId = utxo.assetID\n            const amount = utxo.amount\n            const amountBN = new BN(amount)\n\n            // Get who sent this to you\n            const senders: string[] = []\n            ins.forEach((input) => {\n                const utxo = input.output\n                if (utxo.assetID === assetId) {\n                    const outAddrs = utxo.addresses\n                    // If not a wallet address and not added to senders\n                    const targets = outAddrs.filter(\n                        (addr: string) => !addrsStripped.includes(addr) && !senders.includes(addr)\n                    )\n                    senders.push(...targets)\n                }\n            })\n\n            addToDict(assetId, amountBN, profit, utxo, senders)\n        }\n    }\n\n    return profit\n}\n\n// Finds the absolute gains and losses for the active wallet given transaction data from the explorer\nfunction getTransactionSummary(tx: ITransactionData, wallet: WalletType) {\n    const losses = getLoss(tx, wallet)\n    const profits = getProfit(tx, wallet)\n\n    const nftSummary = getNFTsSummary(tx, wallet)\n\n    // let nftLoss = getLossNFT(tx, wallet)\n    // let nftGain = getGainNFT()NFT(tx, wallet)\n    // console.log(nftLoss)\n\n    const sum: BaseTxSummary = {\n        tokens: {},\n        collectibles: {\n            sent: nftSummary.sent,\n            received: nftSummary.received,\n        },\n    }\n\n    // First the losses\n    for (const assetId in losses) {\n        const loss = losses[assetId]\n\n        sum.tokens[assetId] = {\n            amount: loss.amount.mul(new BN(-1)),\n            payload: loss.payload,\n            groupNum: loss.groupNum,\n            addresses: loss.addresses,\n        }\n    }\n\n    for (const assetId in profits) {\n        const profit = profits[assetId]\n\n        if (sum.tokens[assetId]) {\n            sum.tokens[assetId].amount = sum.tokens[assetId].amount.add(profit.amount)\n        } else {\n            sum.tokens[assetId] = {\n                amount: profit.amount,\n                payload: profit.payload,\n                groupNum: profit.groupNum,\n                addresses: profit.addresses,\n            }\n        }\n    }\n\n    return sum\n}\n\n/**\n * Given an array of transactions from the explorer, filter out duplicate transactions\n * @param txs\n */\nexport function filterDuplicateTransactions(txs: ITransactionData[]) {\n    const txsIds: string[] = []\n    const filtered: ITransactionData[] = []\n\n    for (let i = 0; i < txs.length; i++) {\n        const tx = txs[i]\n        const txId = tx.id\n\n        if (txsIds.includes(txId)) {\n            continue\n        } else {\n            txsIds.push(txId)\n            filtered.push(tx)\n        }\n    }\n    return filtered\n}\n\nexport { getTransactionSummary }\n","// import AppBtc from \"@ledgerhq/hw-app-btc\";\n//@ts-ignore\nimport AppDjtx from '@obsidiansystems/hw-app-avalanche'\n//@ts-ignore\nimport Eth from '@ledgerhq/hw-app-eth'\n\nimport EthereumjsCommon from '@ethereumjs/common'\nimport { Transaction } from '@ethereumjs/tx'\n\nimport moment from 'moment'\nimport { Buffer, BN } from 'avalanche'\nimport HDKey from 'hdkey'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nconst bippath = require('bip32-path')\nimport createHash from 'create-hash'\nimport store from '@/store'\nimport { importPublic, publicToAddress, bnToRlp, rlp } from 'ethereumjs-util'\n\nimport { UTXO as AVMUTXO, UTXO, UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport { AvaWalletCore } from '@/js/wallets/types'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport {\n    AVMConstants,\n    OperationTx,\n    SelectCredentialClass as AVMSelectCredentialClass,\n    TransferableOperation,\n    Tx as AVMTx,\n    UnsignedTx as AVMUnsignedTx,\n    ImportTx as AVMImportTx,\n} from 'avalanche/dist/apis/avm'\n\nimport {\n    ImportTx as PlatformImportTx,\n    ExportTx as PlatformExportTx,\n    Tx as PlatformTx,\n    UTXO as PlatformUTXO,\n    UnsignedTx as PlatformUnsignedTx,\n    PlatformVMConstants,\n    SelectCredentialClass as PlatformSelectCredentialClass,\n    AddDelegatorTx,\n    AddValidatorTx,\n} from 'avalanche/dist/apis/platformvm'\n\nimport {\n    UnsignedTx as EVMUnsignedTx,\n    ImportTx as EVMImportTx,\n    ExportTx as EVMExportTx,\n    Tx as EvmTx,\n    EVMConstants,\n    EVMInput,\n    SelectCredentialClass as EVMSelectCredentialClass,\n} from 'avalanche/dist/apis/evm'\n\nimport { Credential, SigIdx, Signature, UTXOResponse, Address } from 'avalanche/dist/common'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\nimport { HdWalletCore } from '@/js/wallets/HdWalletCore'\nimport { ILedgerAppConfig } from '@/store/types'\nimport { WalletNameType } from '@/js/wallets/types'\nimport { abiDecoder, web3 } from '@/evm'\nimport { AVA_ACCOUNT_PATH, ETH_ACCOUNT_PATH, LEDGER_ETH_ACCOUNT_PATH } from './MnemonicWallet'\nimport { ChainIdType } from '@/constants'\nimport { ParseableAvmTxEnum, ParseablePlatformEnum, ParseableEvmTxEnum } from '../TxHelper'\nimport { ILedgerBlockMessage } from '../../store/modules/ledger/types'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletHelper } from '@/helpers/wallet_helper'\nimport { bnToBig, idToChainAlias } from '@avalabs/avalanche-wallet-sdk'\n\nexport const MIN_EVM_SUPPORT_V = '0.5.3'\n\nclass LedgerWallet extends HdWalletCore implements AvaWalletCore {\n    app: AppDjtx\n    ethApp: Eth\n    type: WalletNameType\n\n    ethAddress: string\n    ethBalance: BN\n    config: ILedgerAppConfig\n    ethHdNode: HDKey\n\n    constructor(app: AppDjtx, hdkey: HDKey, config: ILedgerAppConfig, hdEth: HDKey, ethApp: Eth) {\n        super(hdkey, hdEth)\n        this.app = app\n        this.ethApp = ethApp\n        this.type = 'ledger'\n        this.config = config\n        this.ethHdNode = hdEth\n\n        if (hdEth) {\n            const ethKey = hdEth\n            const ethPublic = importPublic(ethKey.publicKey)\n            this.ethAddress = publicToAddress(ethPublic).toString('hex')\n            this.ethBalance = new BN(0)\n        } else {\n            this.ethAddress = ''\n            this.ethBalance = new BN(0)\n        }\n    }\n\n    static async fromApp(app: AppDjtx, eth: Eth, config: ILedgerAppConfig) {\n        const res = await app.getWalletExtendedPublicKey(AVA_ACCOUNT_PATH)\n\n        const hd = new HDKey()\n        hd.publicKey = res.public_key\n        hd.chainCode = res.chain_code\n\n        const ethRes = await eth.getAddress(LEDGER_ETH_ACCOUNT_PATH, true, true)\n        const hdEth = new HDKey()\n        // @ts-ignore\n        hdEth.publicKey = Buffer.from(ethRes.publicKey, 'hex')\n        // @ts-ignore\n        hdEth.chainCode = Buffer.from(ethRes.chainCode, 'hex')\n\n        return new LedgerWallet(app, hd, config, hdEth, eth)\n    }\n\n    // Returns an array of derivation paths that need to sign this transaction\n    // Used with signTransactionHash and signTransactionParsable\n    getTransactionPaths<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): { paths: string[]; isDjtxOnly: boolean } {\n        // TODO: This is a nasty fix. Remove when AJS is updated.\n        unsignedTx.toBuffer()\n        const tx = unsignedTx.getTransaction()\n        const txType = tx.getTxType()\n\n        const ins = tx.getIns()\n        let operations: TransferableOperation[] = []\n\n        // Try to get operations, it will fail if there are none, ignore and continue\n        try {\n            operations = (tx as OperationTx).getOperations()\n        } catch (e) {\n            console.log(e)\n        }\n\n        let items = ins\n        if (\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P')\n        ) {\n            items = ((tx as AVMImportTx) || PlatformImportTx).getImportInputs()\n        }\n\n        const hrp = getPreferredHRP(ava.getNetworkID())\n        const paths: string[] = []\n\n        let isDjtxOnly = true\n\n        // Collect derivation paths for source addresses\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i]\n\n            const assetId = bintools.cb58Encode(item.getAssetID())\n            // @ts-ignore\n            if (assetId !== store.state.Assets.AVA_ASSET_ID) {\n                isDjtxOnly = false\n            }\n\n            const sigidxs: SigIdx[] = item.getInput().getSigIdxs()\n            const sources = sigidxs.map((sigidx) => sigidx.getSource())\n            const addrs: string[] = sources.map((source) => {\n                return bintools.addressToString(hrp, chainId, source)\n            })\n\n            for (let j = 0; j < addrs.length; j++) {\n                const srcAddr = addrs[j]\n                const pathStr = this.getPathFromAddress(srcAddr) // returns change/index\n\n                paths.push(pathStr)\n            }\n        }\n\n        // Do the Same for operational inputs, if there are any...\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i]\n            const sigidxs: SigIdx[] = op.getOperation().getSigIdxs()\n            const sources = sigidxs.map((sigidx) => sigidx.getSource())\n            const addrs: string[] = sources.map((source) => {\n                return bintools.addressToString(hrp, chainId, source)\n            })\n\n            for (let j = 0; j < addrs.length; j++) {\n                const srcAddr = addrs[j]\n                const pathStr = this.getPathFromAddress(srcAddr) // returns change/index\n\n                paths.push(pathStr)\n            }\n        }\n\n        return { paths, isDjtxOnly }\n    }\n\n    pathsToUniqueBipPaths(paths: string[]) {\n        const uniquePaths = paths.filter((val: any, i: number) => {\n            return paths.indexOf(val) === i\n        })\n\n        const bip32Paths = uniquePaths.map((path) => {\n            return bippath.fromString(path, false)\n        })\n\n        return bip32Paths\n    }\n\n    getChangeBipPath<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ) {\n        if (chainId === 'C') {\n            return null\n        }\n\n        const tx = unsignedTx.getTransaction()\n        const txType = tx.getTxType()\n\n        const chainChangePath = this.getChangePath(chainId).split('m/')[1]\n        let changeIdx = this.getChangeIndex(chainId)\n        // If change and destination paths are the same\n        // it can cause ledger to not display the destination amt.\n        // Since platform helper does not have internal/external\n        // path for change (it uses the next address)\n        // there can be an address collisions.\n        if (\n            (txType === PlatformVMConstants.IMPORTTX || txType === PlatformVMConstants.EXPORTTX) &&\n            this.platformHelper.hdIndex === this.externalHelper.hdIndex\n        ) {\n            return null\n        } else if (\n            txType === PlatformVMConstants.ADDVALIDATORTX ||\n            txType === PlatformVMConstants.ADDDELEGATORTX\n        ) {\n            changeIdx = this.platformHelper.getFirstAvailableIndex()\n        }\n\n        return bippath.fromString(`${AVA_ACCOUNT_PATH}/${chainChangePath}/${changeIdx}`)\n    }\n\n    getCredentials<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        paths: string[],\n        sigMap: any,\n        chainId: ChainIdType\n    ): Credential[] {\n        const creds: Credential[] = []\n        const tx = unsignedTx.getTransaction()\n        const txType = tx.getTxType()\n\n        // @ts-ignore\n        const ins = tx.getIns ? tx.getIns() : []\n        let operations: TransferableOperation[] = []\n        let evmInputs: EVMInput[] = []\n\n        let items = ins\n        if (\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P') ||\n            (txType === EVMConstants.IMPORTTX && chainId === 'C')\n        ) {\n            items = ((tx as AVMImportTx) || PlatformImportTx || EVMImportTx).getImportInputs()\n        }\n\n        // Try to get operations, it will fail if there are none, ignore and continue\n        try {\n            operations = (tx as OperationTx).getOperations()\n        } catch (e) {\n            console.error(e)\n        }\n\n        let CredentialClass\n        if (chainId === 'X') {\n            CredentialClass = AVMSelectCredentialClass\n        } else if (chainId === 'P') {\n            CredentialClass = PlatformSelectCredentialClass\n        } else {\n            CredentialClass = EVMSelectCredentialClass\n        }\n\n        // Try to get evm inputs, it will fail if there are none, ignore and continue\n        try {\n            evmInputs = (tx as EVMExportTx).getInputs()\n        } catch (e) {\n            console.error(e)\n        }\n\n        for (let i = 0; i < items.length; i++) {\n            const sigidxs: SigIdx[] = items[i].getInput().getSigIdxs()\n            const cred: Credential = CredentialClass(items[i].getInput().getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                const pathIndex = i + j\n                const pathStr = paths[pathIndex]\n\n                const sigRaw = sigMap.get(pathStr)\n                const sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i].getOperation()\n            const sigidxs: SigIdx[] = op.getSigIdxs()\n            const cred: Credential = CredentialClass(op.getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                const pathIndex = items.length + i + j\n                const pathStr = paths[pathIndex]\n\n                const sigRaw = sigMap.get(pathStr)\n                const sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        for (let i = 0; i < evmInputs.length; i++) {\n            const evmInput = evmInputs[i]\n            const sigidxs: SigIdx[] = evmInput.getSigIdxs()\n            const cred: Credential = CredentialClass(evmInput.getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                const pathIndex = items.length + i + j\n                const pathStr = paths[pathIndex]\n\n                const sigRaw = sigMap.get(pathStr)\n                const sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        return creds\n    }\n\n    // Used for non parsable transactions.\n    // Ideally we wont use this function at all, but ledger is not ready yet.\n    async signTransactionHash<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx | EvmTx\n    >(unsignedTx: UnsignedTx, paths: string[], chainId: ChainIdType): Promise<SignedTx> {\n        const txbuff = unsignedTx.toBuffer()\n        const msg: Buffer = Buffer.from(createHash('sha256').update(txbuff).digest())\n\n        try {\n            store.commit('Ledger/openModal', {\n                title: 'Sign Hash',\n                messages: [],\n                info: msg.toString('hex').toUpperCase(),\n            })\n\n            const bip32Paths = this.pathsToUniqueBipPaths(paths)\n\n            // Sign the msg with ledger\n            const accountPathSource = chainId === 'C' ? ETH_ACCOUNT_PATH : AVA_ACCOUNT_PATH\n            const accountPath = bippath.fromString(`${accountPathSource}`)\n            const sigMap = await this.app.signHash(accountPath, bip32Paths, msg)\n            store.commit('Ledger/closeModal')\n\n            const creds: Credential[] = this.getCredentials<UnsignedTx>(\n                unsignedTx,\n                paths,\n                sigMap,\n                chainId\n            )\n\n            let signedTx\n            switch (chainId) {\n                case 'X':\n                    signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds)\n                    break\n                case 'P':\n                    signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds)\n                    break\n                case 'C':\n                    signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds)\n                    break\n            }\n\n            return signedTx as SignedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    // Used for signing transactions that are parsable\n    async signTransactionParsable<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx | EvmTx\n    >(unsignedTx: UnsignedTx, paths: string[], chainId: ChainIdType): Promise<SignedTx> {\n        const tx = unsignedTx.getTransaction()\n        const txType = tx.getTxType()\n        const parseableTxs = {\n            X: ParseableAvmTxEnum,\n            P: ParseablePlatformEnum,\n            C: ParseableEvmTxEnum,\n        }[chainId]\n\n        const title = `Sign ${parseableTxs[txType]}`\n\n        const bip32Paths = this.pathsToUniqueBipPaths(paths)\n\n        const accountPath =\n            chainId === 'C'\n                ? bippath.fromString(`${ETH_ACCOUNT_PATH}`)\n                : bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n        const txbuff = unsignedTx.toBuffer()\n        const changePath = this.getChangeBipPath(unsignedTx, chainId)\n        const messages = this.getTransactionMessages<UnsignedTx>(unsignedTx, chainId, changePath)\n\n        try {\n            store.commit('Ledger/openModal', {\n                title: title,\n                messages: messages,\n                info: null,\n            })\n\n            const ledgerSignedTx = await this.app.signTransaction(\n                accountPath,\n                bip32Paths,\n                txbuff,\n                changePath\n            )\n\n            const sigMap = ledgerSignedTx.signatures\n            const creds = this.getCredentials<UnsignedTx>(unsignedTx, paths, sigMap, chainId)\n\n            let signedTx\n            switch (chainId) {\n                case 'X':\n                    signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds)\n                    break\n                case 'P':\n                    signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds)\n                    break\n                case 'C':\n                    signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds)\n                    break\n            }\n\n            return signedTx as SignedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    getOutputMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType,\n        changePath: null | { toPathArray: () => number[] }\n    ): ILedgerBlockMessage[] {\n        const messages: ILedgerBlockMessage[] = []\n        const hrp = getPreferredHRP(ava.getNetworkID())\n        const tx = unsignedTx.getTransaction()\n        const txType = tx.getTxType()\n\n        // @ts-ignore\n        let outs\n        if (\n            (txType === AVMConstants.EXPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.EXPORTTX && chainId === 'P')\n        ) {\n            outs = (tx as PlatformExportTx).getExportOutputs()\n        } else if (txType === EVMConstants.EXPORTTX && chainId === 'C') {\n            outs = (tx as EVMExportTx).getExportedOutputs()\n        } else {\n            outs = (tx as PlatformExportTx).getOuts()\n        }\n\n        let destinationChain = chainId\n        if (chainId === 'C' && txType === EVMConstants.EXPORTTX) destinationChain = 'X'\n\n        if (destinationChain === 'C') {\n            for (let i = 0; i < outs.length; i++) {\n                // @ts-ignore\n                const value = outs[i].getAddress()\n                const addr = bintools.addressToString(hrp, chainId, value)\n                // @ts-ignore\n                const amt = bnToBig(outs[i].getAmount(), 9)\n\n                messages.push({\n                    title: 'Output',\n                    value: `${addr} - ${amt.toString()} DJTX`,\n                })\n            }\n        } else {\n            const changeIdx = changePath?.toPathArray()[changePath?.toPathArray().length - 1]\n            const changeAddr = this.getChangeFromIndex(changeIdx, destinationChain)\n\n            for (let i = 0; i < outs.length; i++) {\n                outs[i]\n                    .getOutput()\n                    .getAddresses()\n                    .forEach((value) => {\n                        const addr = bintools.addressToString(hrp, chainId, value)\n                        // @ts-ignore\n                        const amt = bnToBig(outs[i].getOutput().getAmount(), 9)\n\n                        if (!changePath || changeAddr !== addr)\n                            messages.push({\n                                title: 'Output',\n                                value: `${addr} - ${amt.toString()} DJTX`,\n                            })\n                    })\n            }\n        }\n\n        return messages\n    }\n\n    getValidateDelegateMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): ILedgerBlockMessage[] {\n        const tx =\n            ((unsignedTx as\n                | AVMUnsignedTx\n                | PlatformUnsignedTx).getTransaction() as AddValidatorTx) || AddDelegatorTx\n        const txType = tx.getTxType()\n        const messages: ILedgerBlockMessage[] = []\n\n        if (\n            (txType === PlatformVMConstants.ADDDELEGATORTX && chainId === 'P') ||\n            (txType === PlatformVMConstants.ADDVALIDATORTX && chainId === 'P')\n        ) {\n            const format = 'YYYY-MM-DD H:mm:ss UTC'\n\n            const nodeID = bintools.cb58Encode(tx.getNodeID())\n            const startTime = moment(tx.getStartTime().toNumber() * 1000)\n                .utc()\n                .format(format)\n\n            const endTime = moment(tx.getEndTime().toNumber() * 1000)\n                .utc()\n                .format(format)\n\n            const stakeAmt = bnToBig(tx.getStakeAmount(), 9)\n\n            const rewardOwners = tx.getRewardOwners()\n            const hrp = ava.getHRP()\n            const rewardAddrs = rewardOwners\n                .getOutput()\n                .getAddresses()\n                .map((addr) => {\n                    return bintools.addressToString(hrp, chainId, addr)\n                })\n\n            messages.push({ title: 'NodeID', value: nodeID })\n            messages.push({ title: 'Start Time', value: startTime })\n            messages.push({ title: 'End Time', value: endTime })\n            messages.push({ title: 'Total Stake', value: `${stakeAmt} DJTX` })\n            messages.push({\n                title: 'Stake',\n                value: `${stakeAmt} to ${this.platformHelper.getCurrentAddress()}`,\n            })\n            messages.push({\n                title: 'Reward to',\n                value: `${rewardAddrs.join('\\n')}`,\n            })\n            // @ts-ignore\n            if (tx.delegationFee) {\n                // @ts-ignore\n                messages.push({ title: 'Delegation Fee', value: `${tx.delegationFee}%` })\n            }\n            messages.push({ title: 'Fee', value: '0' })\n        }\n\n        return messages\n    }\n\n    getFeeMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): ILedgerBlockMessage[] {\n        const tx = unsignedTx.getTransaction()\n        const txType = tx.getTxType()\n        const messages = []\n\n        if (\n            (txType === AVMConstants.BASETX && chainId === 'X') ||\n            (txType === AVMConstants.EXPORTTX && chainId === 'X') ||\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.EXPORTTX && chainId === 'P') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P') ||\n            (txType === EVMConstants.EXPORTTX && chainId === 'C') ||\n            (txType === EVMConstants.IMPORTTX && chainId === 'C')\n        ) {\n            messages.push({ title: 'Fee', value: `${0.001} DJTX` })\n        }\n\n        return messages\n    }\n\n    // Given the unsigned transaction returns an array of messages that will be displayed on ledgegr window\n    getTransactionMessages<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType,\n        changePath: null | { toPathArray: () => number[] }\n    ): ILedgerBlockMessage[] {\n        const messages: ILedgerBlockMessage[] = []\n\n        const outputMessages = this.getOutputMsgs(unsignedTx, chainId, changePath)\n        messages.push(...outputMessages)\n\n        const validateDelegateMessages = this.getValidateDelegateMsgs(\n            unsignedTx as AVMUnsignedTx | PlatformUnsignedTx,\n            chainId\n        )\n        messages.push(...validateDelegateMessages)\n\n        const feeMessages = this.getFeeMsgs(unsignedTx, chainId)\n        messages.push(...feeMessages)\n\n        return messages\n    }\n\n    getEvmTransactionMessages(tx: Transaction): ILedgerBlockMessage[] {\n        const gasPrice = tx.gasPrice\n        const gasLimit = tx.gasLimit\n        const totFee = gasPrice.mul(new BN(gasLimit))\n        const feeNano = bnToBig(totFee, 9)\n\n        let msgs: ILedgerBlockMessage[] = []\n        try {\n            const test = '0x' + tx.data.toString('hex')\n            const data = abiDecoder.decodeMethod(test)\n\n            const callMsg: ILedgerBlockMessage = {\n                title: 'Contract Call',\n                value: data.name,\n            }\n            const paramMsgs: ILedgerBlockMessage[] = data.params.map((param: any) => {\n                return {\n                    title: param.name,\n                    value: param.value,\n                }\n            })\n\n            const feeMsg: ILedgerBlockMessage = {\n                title: 'Fee',\n                value: feeNano.toLocaleString() + ' nDJTX',\n            }\n\n            msgs = [callMsg, ...paramMsgs, feeMsg]\n        } catch (e) {\n            console.log(e)\n        }\n        return msgs\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        const tx = unsignedTx.getTransaction()\n        const txType = tx.getTxType()\n        const chainId: ChainIdType = 'X'\n\n        const parseableTxs = ParseableAvmTxEnum\n        const { paths, isDjtxOnly } = this.getTransactionPaths<AVMUnsignedTx>(unsignedTx, chainId)\n\n        // If ledger doesnt support parsing, sign hash\n        const canLedgerParse = this.config.version >= '0.3.1'\n        const isParsableType = txType in parseableTxs && isDjtxOnly\n\n        let signedTx\n        if (canLedgerParse && isParsableType) {\n            signedTx = await this.signTransactionParsable<AVMUnsignedTx, AVMTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        } else {\n            signedTx = await this.signTransactionHash<AVMUnsignedTx, AVMTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        }\n\n        store.commit('Ledger/closeModal')\n        return signedTx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        const tx = unsignedTx.getTransaction()\n        const txType = tx.getTxType()\n        const chainId: ChainIdType = 'P'\n        const parseableTxs = ParseablePlatformEnum\n\n        const { paths, isDjtxOnly } = this.getTransactionPaths<PlatformUnsignedTx>(\n            unsignedTx,\n            chainId\n        )\n        // If ledger doesnt support parsing, sign hash\n        let canLedgerParse = this.config.version >= '0.3.1'\n        const isParsableType = txType in parseableTxs && isDjtxOnly\n\n        // TODO: Remove after ledger is fixed\n        // If UTXOS contain lockedStakeable funds always use sign hash\n        const txIns = unsignedTx.getTransaction().getIns()\n        for (let i = 0; i < txIns.length; i++) {\n            const typeID = txIns[i].getInput().getTypeID()\n            if (typeID === PlatformVMConstants.STAKEABLELOCKINID) {\n                canLedgerParse = false\n                break\n            }\n        }\n\n        // TODO: Remove after ledger update\n        // Ledger is not able to parse P/C atomic transactions\n        if (txType === PlatformVMConstants.EXPORTTX) {\n            const destChainBuff = (tx as PlatformExportTx).getDestinationChain()\n            // If destination chain is C chain, sign hash\n            const destChain = idToChainAlias(bintools.cb58Encode(destChainBuff))\n            if (destChain === 'C') {\n                canLedgerParse = false\n            }\n        }\n        // TODO: Remove after ledger update\n        if (txType === PlatformVMConstants.IMPORTTX) {\n            const sourceChainBuff = (tx as PlatformImportTx).getSourceChain()\n            // If destination chain is C chain, sign hash\n            const sourceChain = idToChainAlias(bintools.cb58Encode(sourceChainBuff))\n            if (sourceChain === 'C') {\n                canLedgerParse = false\n            }\n        }\n\n        let signedTx\n        if (canLedgerParse && isParsableType) {\n            signedTx = await this.signTransactionParsable<PlatformUnsignedTx, PlatformTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        } else {\n            signedTx = await this.signTransactionHash<PlatformUnsignedTx, PlatformTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        }\n        store.commit('Ledger/closeModal')\n        return signedTx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        // TODO: Might need to upgrade paths array to:\n        //  paths = Array(utxoSet.getAllUTXOs().length).fill('0/0'),\n        const tx = unsignedTx.getTransaction()\n        const typeId = tx.getTxType()\n\n        let canLedgerParse = true\n\n        let paths = ['0/0']\n        if (typeId === EVMConstants.EXPORTTX) {\n            const ins = (tx as EVMExportTx).getInputs()\n            paths = ins.map((input) => '0/0')\n        } else if (typeId === EVMConstants.IMPORTTX) {\n            const ins = (tx as EVMImportTx).getImportInputs()\n            paths = ins.map((input) => '0/0')\n        }\n\n        // TODO: Remove after ledger update\n        // Ledger is not able to parse P/C atomic transactions\n        if (typeId === EVMConstants.EXPORTTX) {\n            const destChainBuff = (tx as EVMExportTx).getDestinationChain()\n            // If destination chain is C chain, sign hash\n            const destChain = idToChainAlias(bintools.cb58Encode(destChainBuff))\n            if (destChain === 'P') {\n                canLedgerParse = false\n            }\n        }\n        // TODO: Remove after ledger update\n        if (typeId === EVMConstants.IMPORTTX) {\n            const sourceChainBuff = (tx as EVMImportTx).getSourceChain()\n            // If destination chain is C chain, sign hash\n            const sourceChain = idToChainAlias(bintools.cb58Encode(sourceChainBuff))\n            if (sourceChain === 'P') {\n                canLedgerParse = false\n            }\n        }\n\n        let txSigned\n        if (canLedgerParse) {\n            txSigned = (await this.signTransactionParsable(unsignedTx, paths, 'C')) as EvmTx\n        } else {\n            txSigned = (await this.signTransactionHash(unsignedTx, paths, 'C')) as EvmTx\n        }\n        store.commit('Ledger/closeModal')\n        return txSigned\n    }\n\n    async signEvm(tx: Transaction) {\n        const rawUnsignedTx = rlp.encode([\n            bnToRlp(tx.nonce),\n            bnToRlp(tx.gasPrice),\n            bnToRlp(tx.gasLimit),\n            tx.to !== undefined ? tx.to.buf : Buffer.from([]),\n            bnToRlp(tx.value),\n            tx.data,\n            bnToRlp(new BN(tx.getChainId())),\n            Buffer.from([]),\n            Buffer.from([]),\n        ])\n\n        try {\n            const msgs = this.getEvmTransactionMessages(tx)\n\n            // Open Modal Prompt\n            store.commit('Ledger/openModal', {\n                title: 'Transfer',\n                messages: msgs,\n                info: null,\n            })\n            const signature = await this.ethApp.signTransaction(\n                LEDGER_ETH_ACCOUNT_PATH,\n                rawUnsignedTx.toString('hex')\n            )\n            store.commit('Ledger/closeModal')\n\n            const signatureBN = {\n                v: new BN(signature.v, 16),\n                r: new BN(signature.r, 16),\n                s: new BN(signature.s, 16),\n            }\n\n            const chainId = await web3.eth.getChainId()\n            const networkId = await web3.eth.net.getId()\n            const chainParams = {\n                common: EthereumjsCommon.forCustomChain(\n                    'mainnet',\n                    { networkId, chainId },\n                    'istanbul'\n                ),\n            }\n\n            const signedTx = Transaction.fromTxData(\n                {\n                    nonce: tx.nonce,\n                    gasPrice: tx.gasPrice,\n                    gasLimit: tx.gasLimit,\n                    to: tx.to,\n                    value: tx.value,\n                    data: tx.data,\n                    ...signatureBN,\n                },\n                chainParams\n            )\n            return signedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    async getEthBalance() {\n        const bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async getUTXOs(): Promise<void> {\n        // TODO: Move to shared file\n        this.isFetchUtxos = true\n        // If we are waiting for helpers to initialize delay the call\n        const isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n        if (!isInit) {\n            setTimeout(() => {\n                this.getUTXOs()\n            }, 1000)\n            return\n        }\n\n        super.getUTXOs()\n        this.getStake()\n        this.getEthBalance()\n        return\n    }\n\n    getPathFromAddress(address: string) {\n        const externalAddrs = this.externalHelper.getExtendedAddresses()\n        const internalAddrs = this.internalHelper.getExtendedAddresses()\n        const platformAddrs = this.platformHelper.getExtendedAddresses()\n\n        const extIndex = externalAddrs.indexOf(address)\n        const intIndex = internalAddrs.indexOf(address)\n        const platformIndex = platformAddrs.indexOf(address)\n\n        if (extIndex >= 0) {\n            return `0/${extIndex}`\n        } else if (intIndex >= 0) {\n            return `1/${intIndex}`\n        } else if (platformIndex >= 0) {\n            return `0/${platformIndex}`\n        } else if (address[0] === 'C') {\n            return '0/0'\n        } else {\n            throw 'Unable to find source address.'\n        }\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: Buffer | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    async signHashByExternalIndex(index: number, hash: Buffer) {\n        const pathStr = `0/${index}`\n        const addressPath = bippath.fromString(pathStr, false)\n        const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n\n        store.commit('Ledger/openModal', {\n            title: `Sign Hash`,\n            info: hash.toString('hex').toUpperCase(),\n        })\n\n        try {\n            const sigMap = await this.app.signHash(accountPath, [addressPath], hash)\n            store.commit('Ledger/closeModal')\n            const signed = sigMap.get(pathStr)\n            return bintools.cb58Encode(signed)\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            throw e\n        }\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        // throw 'Not Implemented'\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n}\n\nexport { LedgerWallet }\n","import { Tx as AVMTx } from 'avalanche/dist/apis/avm/tx'\nimport { xChain } from '@avalabs/avalanche-wallet-sdk'\nimport { bintools, cChain, pChain } from '@/AVA'\nimport { Tx as PlatformTx } from 'avalanche/dist/apis/platformvm/tx'\nimport { Tx as EVMTx } from 'avalanche/dist/apis/evm/tx'\n\nexport async function issueX(tx: AVMTx) {\n    return xChain.issueTx('0x' + bintools.addChecksum(tx.toBuffer()).toString('hex'))\n}\n\nexport async function issueP(tx: PlatformTx) {\n    return pChain.issueTx('0x' + bintools.addChecksum(tx.toBuffer()).toString('hex'))\n}\n\nexport async function issueC(tx: EVMTx) {\n    return cChain.issueTx('0x' + bintools.addChecksum(tx.toBuffer()).toString('hex'))\n}\n","import { generateMnemonic } from 'bip39'\n\n/**\n * Returns a random word from a new mnemonic phrase.\n */\nexport function getRandomMnemonicWord() {\n    const words = generateMnemonic(256).split(' ')\n    const rand = Math.round(Math.random() * words.length)\n    return words[rand]\n}\n","var isoLangs = {\n    ab: {\n        name: 'Abkhaz',\n        nativeName: 'аҧсуа',\n    },\n    aa: {\n        name: 'Afar',\n        nativeName: 'Afaraf',\n    },\n    af: {\n        name: 'Afrikaans',\n        nativeName: 'Afrikaans',\n    },\n    ak: {\n        name: 'Akan',\n        nativeName: 'Akan',\n    },\n    sq: {\n        name: 'Albanian',\n        nativeName: 'Shqip',\n    },\n    am: {\n        name: 'Amharic',\n        nativeName: 'አማርኛ',\n    },\n    ar: {\n        name: 'Arabic',\n        nativeName: 'العربية',\n    },\n    an: {\n        name: 'Aragonese',\n        nativeName: 'Aragonés',\n    },\n    hy: {\n        name: 'Armenian',\n        nativeName: 'Հայերեն',\n    },\n    as: {\n        name: 'Assamese',\n        nativeName: 'অসমীয়া',\n    },\n    av: {\n        name: 'Avaric',\n        nativeName: 'авар мацӀ, магӀарул мацӀ',\n    },\n    ae: {\n        name: 'Avestan',\n        nativeName: 'avesta',\n    },\n    ay: {\n        name: 'Aymara',\n        nativeName: 'aymar aru',\n    },\n    az: {\n        name: 'Azerbaijani',\n        nativeName: 'azərbaycan dili',\n    },\n    bm: {\n        name: 'Bambara',\n        nativeName: 'bamanankan',\n    },\n    ba: {\n        name: 'Bashkir',\n        nativeName: 'башҡорт теле',\n    },\n    eu: {\n        name: 'Basque',\n        nativeName: 'euskara, euskera',\n    },\n    be: {\n        name: 'Belarusian',\n        nativeName: 'Беларуская',\n    },\n    bn: {\n        name: 'Bengali',\n        nativeName: 'বাংলা',\n    },\n    bh: {\n        name: 'Bihari',\n        nativeName: 'भोजपुरी',\n    },\n    bi: {\n        name: 'Bislama',\n        nativeName: 'Bislama',\n    },\n    bs: {\n        name: 'Bosnian',\n        nativeName: 'bosanski jezik',\n    },\n    br: {\n        name: 'Breton',\n        nativeName: 'brezhoneg',\n    },\n    bg: {\n        name: 'Bulgarian',\n        nativeName: 'български език',\n    },\n    my: {\n        name: 'Burmese',\n        nativeName: 'ဗမာစာ',\n    },\n    ca: {\n        name: 'Catalan; Valencian',\n        nativeName: 'Català',\n    },\n    ch: {\n        name: 'Chamorro',\n        nativeName: 'Chamoru',\n    },\n    ce: {\n        name: 'Chechen',\n        nativeName: 'нохчийн мотт',\n    },\n    ny: {\n        name: 'Chichewa; Chewa; Nyanja',\n        nativeName: 'chiCheŵa, chinyanja',\n    },\n    cn: {\n        name: 'Chinese',\n        nativeName: '中文 (Zhōngwén), 汉语, 漢語',\n    },\n    zh_hans: {\n        name: 'Chinese (Simplified)',\n        nativeName: '汉语',\n    },\n    zh_hant: {\n        name: 'Chinese (Traditional)',\n        nativeName: '漢語',\n    },\n    cv: {\n        name: 'Chuvash',\n        nativeName: 'чӑваш чӗлхи',\n    },\n    kw: {\n        name: 'Cornish',\n        nativeName: 'Kernewek',\n    },\n    co: {\n        name: 'Corsican',\n        nativeName: 'corsu, lingua corsa',\n    },\n    cr: {\n        name: 'Cree',\n        nativeName: 'ᓀᐦᐃᔭᐍᐏᐣ',\n    },\n    hr: {\n        name: 'Croatian',\n        nativeName: 'hrvatski',\n    },\n    cs: {\n        name: 'Czech',\n        nativeName: 'česky, čeština',\n    },\n    da: {\n        name: 'Danish',\n        nativeName: 'dansk',\n    },\n    dv: {\n        name: 'Divehi; Dhivehi; Maldivian;',\n        nativeName: 'ދިވެހި',\n    },\n    nl: {\n        name: 'Dutch',\n        nativeName: 'Nederlands, Vlaams',\n    },\n    en: {\n        name: 'English',\n        nativeName: 'English',\n    },\n    eo: {\n        name: 'Esperanto',\n        nativeName: 'Esperanto',\n    },\n    et: {\n        name: 'Estonian',\n        nativeName: 'eesti, eesti keel',\n    },\n    ee: {\n        name: 'Ewe',\n        nativeName: 'Eʋegbe',\n    },\n    fo: {\n        name: 'Faroese',\n        nativeName: 'føroyskt',\n    },\n    fj: {\n        name: 'Fijian',\n        nativeName: 'vosa Vakaviti',\n    },\n    fi: {\n        name: 'Finnish',\n        nativeName: 'suomi, suomen kieli',\n    },\n    fr: {\n        name: 'French',\n        nativeName: 'Français',\n    },\n    ff: {\n        name: 'Fula; Fulah; Pulaar; Pular',\n        nativeName: 'Fulfulde, Pulaar, Pular',\n    },\n    gl: {\n        name: 'Galician',\n        nativeName: 'Galego',\n    },\n    ka: {\n        name: 'Georgian',\n        nativeName: 'ქართული',\n    },\n    de: {\n        name: 'German',\n        nativeName: 'Deutsch',\n    },\n    el: {\n        name: 'Greek, Modern',\n        nativeName: 'Ελληνικά',\n    },\n    gn: {\n        name: 'Guaraní',\n        nativeName: 'Avañeẽ',\n    },\n    gu: {\n        name: 'Gujarati',\n        nativeName: 'ગુજરાતી',\n    },\n    ht: {\n        name: 'Haitian; Haitian Creole',\n        nativeName: 'Kreyòl ayisyen',\n    },\n    ha: {\n        name: 'Hausa',\n        nativeName: 'Hausa, هَوُسَ',\n    },\n    he: {\n        name: 'Hebrew (modern)',\n        nativeName: 'עברית',\n    },\n    hz: {\n        name: 'Herero',\n        nativeName: 'Otjiherero',\n    },\n    hi: {\n        name: 'Hindi',\n        nativeName: 'हिन्दी, हिंदी',\n    },\n    ho: {\n        name: 'Hiri Motu',\n        nativeName: 'Hiri Motu',\n    },\n    hu: {\n        name: 'Hungarian',\n        nativeName: 'Magyar',\n    },\n    ia: {\n        name: 'Interlingua',\n        nativeName: 'Interlingua',\n    },\n    id: {\n        name: 'Indonesian',\n        nativeName: 'Bahasa Indonesia',\n    },\n    ie: {\n        name: 'Interlingue',\n        nativeName: 'Originally called Occidental; then Interlingue after WWII',\n    },\n    ga: {\n        name: 'Irish',\n        nativeName: 'Gaeilge',\n    },\n    ig: {\n        name: 'Igbo',\n        nativeName: 'Asụsụ Igbo',\n    },\n    ik: {\n        name: 'Inupiaq',\n        nativeName: 'Iñupiaq, Iñupiatun',\n    },\n    io: {\n        name: 'Ido',\n        nativeName: 'Ido',\n    },\n    is: {\n        name: 'Icelandic',\n        nativeName: 'Íslenska',\n    },\n    it: {\n        name: 'Italian',\n        nativeName: 'Italiano',\n    },\n    iu: {\n        name: 'Inuktitut',\n        nativeName: 'ᐃᓄᒃᑎᑐᑦ',\n    },\n    ja: {\n        name: 'Japanese',\n        nativeName: '日本語',\n    },\n    jv: {\n        name: 'Javanese',\n        nativeName: 'basa Jawa',\n    },\n    kl: {\n        name: 'Kalaallisut, Greenlandic',\n        nativeName: 'kalaallisut, kalaallit oqaasii',\n    },\n    kn: {\n        name: 'Kannada',\n        nativeName: 'ಕನ್ನಡ',\n    },\n    // \"kr\": {\n    //     \"name\": \"Kanuri\",\n    //     \"nativeName\": \"Kanuri\"\n    // },\n    ks: {\n        name: 'Kashmiri',\n        nativeName: 'कश्मीरी, كشميري‎',\n    },\n    kk: {\n        name: 'Kazakh',\n        nativeName: 'Қазақ тілі',\n    },\n    km: {\n        name: 'Khmer',\n        nativeName: 'ភាសាខ្មែរ',\n    },\n    ki: {\n        name: 'Kikuyu, Gikuyu',\n        nativeName: 'Gĩkũyũ',\n    },\n    rw: {\n        name: 'Kinyarwanda',\n        nativeName: 'Ikinyarwanda',\n    },\n    ky: {\n        name: 'Kirghiz, Kyrgyz',\n        nativeName: 'кыргыз тили',\n    },\n    kv: {\n        name: 'Komi',\n        nativeName: 'коми кыв',\n    },\n    kg: {\n        name: 'Kongo',\n        nativeName: 'KiKongo',\n    },\n    kr: {\n        name: 'Korean',\n        nativeName: '한국어',\n    },\n    ku: {\n        name: 'Kurdish',\n        nativeName: 'Kurdî, كوردی‎',\n    },\n    kj: {\n        name: 'Kwanyama, Kuanyama',\n        nativeName: 'Kuanyama',\n    },\n    la: {\n        name: 'Latin',\n        nativeName: 'latine, lingua latina',\n    },\n    lb: {\n        name: 'Luxembourgish, Letzeburgesch',\n        nativeName: 'Lëtzebuergesch',\n    },\n    lg: {\n        name: 'Luganda',\n        nativeName: 'Luganda',\n    },\n    li: {\n        name: 'Limburgish, Limburgan, Limburger',\n        nativeName: 'Limburgs',\n    },\n    ln: {\n        name: 'Lingala',\n        nativeName: 'Lingála',\n    },\n    lo: {\n        name: 'Lao',\n        nativeName: 'ພາສາລາວ',\n    },\n    lt: {\n        name: 'Lithuanian',\n        nativeName: 'lietuvių kalba',\n    },\n    lu: {\n        name: 'Luba-Katanga',\n        nativeName: '',\n    },\n    lv: {\n        name: 'Latvian',\n        nativeName: 'latviešu valoda',\n    },\n    gv: {\n        name: 'Manx',\n        nativeName: 'Gaelg, Gailck',\n    },\n    mk: {\n        name: 'Macedonian',\n        nativeName: 'македонски јазик',\n    },\n    mg: {\n        name: 'Malagasy',\n        nativeName: 'Malagasy fiteny',\n    },\n    ms: {\n        name: 'Malay',\n        nativeName: 'bahasa Melayu, بهاس ملايو‎',\n    },\n    ml: {\n        name: 'Malayalam',\n        nativeName: 'മലയാളം',\n    },\n    mt: {\n        name: 'Maltese',\n        nativeName: 'Malti',\n    },\n    mi: {\n        name: 'Māori',\n        nativeName: 'te reo Māori',\n    },\n    mr: {\n        name: 'Marathi (Marāṭhī)',\n        nativeName: 'मराठी',\n    },\n    mh: {\n        name: 'Marshallese',\n        nativeName: 'Kajin M̧ajeļ',\n    },\n    mn: {\n        name: 'Mongolian',\n        nativeName: 'монгол',\n    },\n    na: {\n        name: 'Nauru',\n        nativeName: 'Ekakairũ Naoero',\n    },\n    nv: {\n        name: 'Navajo, Navaho',\n        nativeName: 'Diné bizaad, Dinékʼehǰí',\n    },\n    nb: {\n        name: 'Norwegian Bokmål',\n        nativeName: 'Norsk bokmål',\n    },\n    nd: {\n        name: 'North Ndebele',\n        nativeName: 'isiNdebele',\n    },\n    ne: {\n        name: 'Nepali',\n        nativeName: 'नेपाली',\n    },\n    ng: {\n        name: 'Ndonga',\n        nativeName: 'Owambo',\n    },\n    nn: {\n        name: 'Norwegian Nynorsk',\n        nativeName: 'Norsk nynorsk',\n    },\n    no: {\n        name: 'Norwegian',\n        nativeName: 'Norsk',\n    },\n    ii: {\n        name: 'Nuosu',\n        nativeName: 'ꆈꌠ꒿ Nuosuhxop',\n    },\n    nr: {\n        name: 'South Ndebele',\n        nativeName: 'isiNdebele',\n    },\n    oc: {\n        name: 'Occitan',\n        nativeName: 'Occitan',\n    },\n    oj: {\n        name: 'Ojibwe, Ojibwa',\n        nativeName: 'ᐊᓂᔑᓈᐯᒧᐎᓐ',\n    },\n    cu: {\n        name: 'Old Church Slavonic, Church Slavic, Church Slavonic, Old Bulgarian, Old Slavonic',\n        nativeName: 'ѩзыкъ словѣньскъ',\n    },\n    om: {\n        name: 'Oromo',\n        nativeName: 'Afaan Oromoo',\n    },\n    or: {\n        name: 'Oriya',\n        nativeName: 'ଓଡ଼ିଆ',\n    },\n    os: {\n        name: 'Ossetian, Ossetic',\n        nativeName: 'ирон æвзаг',\n    },\n    pa: {\n        name: 'Panjabi, Punjabi',\n        nativeName: 'ਪੰਜਾਬੀ, پنجابی‎',\n    },\n    pi: {\n        name: 'Pāli',\n        nativeName: 'पाऴि',\n    },\n    fa: {\n        name: 'Persian',\n        nativeName: 'فارسی',\n    },\n    pl: {\n        name: 'Polish',\n        nativeName: 'polski',\n    },\n    ps: {\n        name: 'Pashto, Pushto',\n        nativeName: 'پښتو',\n    },\n    pt: {\n        name: 'Portuguese',\n        nativeName: 'Português',\n    },\n    qu: {\n        name: 'Quechua',\n        nativeName: 'Runa Simi, Kichwa',\n    },\n    rm: {\n        name: 'Romansh',\n        nativeName: 'rumantsch grischun',\n    },\n    rn: {\n        name: 'Kirundi',\n        nativeName: 'kiRundi',\n    },\n    ro: {\n        name: 'Romanian, Moldavian, Moldovan',\n        nativeName: 'română',\n    },\n    ru: {\n        name: 'Russian',\n        nativeName: 'русский язык',\n    },\n    sa: {\n        name: 'Sanskrit (Saṁskṛta)',\n        nativeName: 'संस्कृतम्',\n    },\n    sc: {\n        name: 'Sardinian',\n        nativeName: 'sardu',\n    },\n    sd: {\n        name: 'Sindhi',\n        nativeName: 'सिन्धी, سنڌي، سندھی‎',\n    },\n    se: {\n        name: 'Northern Sami',\n        nativeName: 'Davvisámegiella',\n    },\n    sm: {\n        name: 'Samoan',\n        nativeName: 'gagana faa Samoa',\n    },\n    sg: {\n        name: 'Sango',\n        nativeName: 'yângâ tî sängö',\n    },\n    sr: {\n        name: 'Serbian',\n        nativeName: 'српски језик',\n    },\n    gd: {\n        name: 'Scottish Gaelic; Gaelic',\n        nativeName: 'Gàidhlig',\n    },\n    sn: {\n        name: 'Shona',\n        nativeName: 'chiShona',\n    },\n    si: {\n        name: 'Sinhala, Sinhalese',\n        nativeName: 'සිංහල',\n    },\n    sk: {\n        name: 'Slovak',\n        nativeName: 'slovenčina',\n    },\n    sl: {\n        name: 'Slovene',\n        nativeName: 'slovenščina',\n    },\n    so: {\n        name: 'Somali',\n        nativeName: 'Soomaaliga, af Soomaali',\n    },\n    st: {\n        name: 'Southern Sotho',\n        nativeName: 'Sesotho',\n    },\n    es: {\n        name: 'Spanish; Castilian',\n        nativeName: 'Español',\n    },\n    su: {\n        name: 'Sundanese',\n        nativeName: 'Basa Sunda',\n    },\n    sw: {\n        name: 'Swahili',\n        nativeName: 'Kiswahili',\n    },\n    ss: {\n        name: 'Swati',\n        nativeName: 'SiSwati',\n    },\n    sv: {\n        name: 'Swedish',\n        nativeName: 'svenska',\n    },\n    ta: {\n        name: 'Tamil',\n        nativeName: 'தமிழ்',\n    },\n    te: {\n        name: 'Telugu',\n        nativeName: 'తెలుగు',\n    },\n    tg: {\n        name: 'Tajik',\n        nativeName: 'тоҷикӣ, toğikī, تاجیکی‎',\n    },\n    th: {\n        name: 'Thai',\n        nativeName: 'ไทย',\n    },\n    ti: {\n        name: 'Tigrinya',\n        nativeName: 'ትግርኛ',\n    },\n    bo: {\n        name: 'Tibetan Standard, Tibetan, Central',\n        nativeName: 'བོད་ཡིག',\n    },\n    tk: {\n        name: 'Turkmen',\n        nativeName: 'Türkmen, Түркмен',\n    },\n    tl: {\n        name: 'Tagalog',\n        nativeName: 'Wikang Tagalog, ᜏᜒᜃᜅ᜔ ᜆᜄᜎᜓᜄ᜔',\n    },\n    tn: {\n        name: 'Tswana',\n        nativeName: 'Setswana',\n    },\n    to: {\n        name: 'Tonga (Tonga Islands)',\n        nativeName: 'faka Tonga',\n    },\n    tr: {\n        name: 'Turkish',\n        nativeName: 'Türkçe',\n    },\n    ts: {\n        name: 'Tsonga',\n        nativeName: 'Xitsonga',\n    },\n    tt: {\n        name: 'Tatar',\n        nativeName: 'татарча, tatarça, تاتارچا‎',\n    },\n    tw: {\n        name: 'Twi',\n        nativeName: 'Twi',\n    },\n    ty: {\n        name: 'Tahitian',\n        nativeName: 'Reo Tahiti',\n    },\n    ug: {\n        name: 'Uighur, Uyghur',\n        nativeName: 'Uyƣurqə, ئۇيغۇرچە‎',\n    },\n    uk: {\n        name: 'Ukrainian',\n        nativeName: 'українська',\n    },\n    ur: {\n        name: 'Urdu',\n        nativeName: 'اردو',\n    },\n    uz: {\n        name: 'Uzbek',\n        nativeName: 'zbek, Ўзбек, أۇزبېك‎',\n    },\n    ve: {\n        name: 'Venda',\n        nativeName: 'Tshivenḓa',\n    },\n    vn: {\n        name: 'Vietnamese',\n        nativeName: 'Tiếng Việt',\n    },\n    vo: {\n        name: 'Volapük',\n        nativeName: 'Volapük',\n    },\n    wa: {\n        name: 'Walloon',\n        nativeName: 'Walon',\n    },\n    cy: {\n        name: 'Welsh',\n        nativeName: 'Cymraeg',\n    },\n    wo: {\n        name: 'Wolof',\n        nativeName: 'Wollof',\n    },\n    fy: {\n        name: 'Western Frisian',\n        nativeName: 'Frysk',\n    },\n    xh: {\n        name: 'Xhosa',\n        nativeName: 'isiXhosa',\n    },\n    yi: {\n        name: 'Yiddish',\n        nativeName: 'ייִדיש',\n    },\n    yo: {\n        name: 'Yoruba',\n        nativeName: 'Yorùbá',\n    },\n    za: {\n        name: 'Zhuang, Chuang',\n        nativeName: 'Saɯ cueŋƅ, Saw cuengh',\n    },\n}\n\nexport default isoLangs\n","import CryptoJS from 'crypto-js/core'\nimport AES from 'crypto-js/aes'\nconst randomstring = require('randomstring')\nimport * as bip39 from 'bip39'\n\n// The purpose of this class is for obfuscation only rather than secure encryption\nexport default class MnemonicPhrase {\n    private pass: string\n    private encrypted: any\n\n    constructor(mnemonic: string) {\n        if (!bip39.validateMnemonic(mnemonic)) throw new Error('Invalid mnemonic phrase.')\n        this.pass = randomstring.generate(32)\n        this.encrypted = AES.encrypt(mnemonic, this.pass).toString()\n    }\n\n    public getValue() {\n        const decrypted = AES.decrypt(this.encrypted, this.pass).toString(CryptoJS.enc.Utf8)\n        if (!bip39.validateMnemonic(decrypted)) throw new Error('Decrypted mnemonic is not valid.')\n        return decrypted\n    }\n}\n","import { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm/utxos'\nimport { avm, cChain, pChain } from '@/AVA'\nimport { BN } from 'avalanche'\n\nexport async function getStakeForAddresses(addrs: string[]): Promise<BN> {\n    if (addrs.length <= 256) {\n        const stakeData = await pChain.getStake(addrs)\n        return stakeData.staked\n    } else {\n        //Break the list in to 1024 chunks\n        const chunk = addrs.slice(0, 256)\n        const remainingChunk = addrs.slice(256)\n\n        const stakeData = await pChain.getStake(chunk)\n        const chunkStake = stakeData.staked\n        return chunkStake.add(await getStakeForAddresses(remainingChunk))\n    }\n}\n\nexport async function avmGetAllUTXOs(addrs: string[]): Promise<AVMUTXOSet> {\n    if (addrs.length <= 1024) {\n        const utxos = await avmGetAllUTXOsForAddresses(addrs)\n        return utxos\n    } else {\n        //Break the list in to 1024 chunks\n        const chunk = addrs.slice(0, 1024)\n        const remainingChunk = addrs.slice(1024)\n\n        const newSet = await avmGetAllUTXOsForAddresses(chunk)\n        return newSet.merge(await avmGetAllUTXOs(remainingChunk))\n    }\n}\n\nexport async function avmGetAllUTXOsForAddresses(\n    addrs: string[],\n    endIndex: any = undefined\n): Promise<AVMUTXOSet> {\n    if (addrs.length > 1024) throw new Error('Maximum length of addresses is 1024')\n    let response\n    if (!endIndex) {\n        response = await avm.getUTXOs(addrs)\n    } else {\n        response = await avm.getUTXOs(addrs, undefined, 0, endIndex)\n    }\n\n    const utxoSet = response.utxos\n    const utxos = utxoSet.getAllUTXOs()\n    const nextEndIndex = response.endIndex\n    const len = response.numFetched\n\n    if (len >= 1024) {\n        const subUtxos = await avmGetAllUTXOsForAddresses(addrs, nextEndIndex)\n        return utxoSet.merge(subUtxos)\n    }\n    return utxoSet\n}\n\n// helper method to get utxos for more than 1024 addresses\nexport async function platformGetAllUTXOs(addrs: string[]): Promise<PlatformUTXOSet> {\n    if (addrs.length <= 1024) {\n        const newSet = await platformGetAllUTXOsForAddresses(addrs)\n        return newSet\n    } else {\n        //Break the list in to 1024 chunks\n        const chunk = addrs.slice(0, 1024)\n        const remainingChunk = addrs.slice(1024)\n\n        const newSet = await platformGetAllUTXOsForAddresses(chunk)\n\n        return newSet.merge(await platformGetAllUTXOs(remainingChunk))\n    }\n}\n\nexport async function platformGetAllUTXOsForAddresses(\n    addrs: string[],\n    endIndex: any = undefined\n): Promise<PlatformUTXOSet> {\n    let response\n    if (!endIndex) {\n        response = await pChain.getUTXOs(addrs)\n    } else {\n        response = await pChain.getUTXOs(addrs, undefined, 0, endIndex)\n    }\n\n    const utxoSet = response.utxos\n    const nextEndIndex = response.endIndex\n    const len = response.numFetched\n\n    if (len >= 1024) {\n        const subUtxos = await platformGetAllUTXOsForAddresses(addrs, nextEndIndex)\n        return utxoSet.merge(subUtxos)\n    }\n\n    return utxoSet\n}\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { digestMessage } from '@/helpers/helper'\nimport { WalletNameType } from '@/js/wallets/types'\n\nimport { Buffer as BufferAvalanche, BN } from 'avalanche'\nimport {\n    KeyPair as AVMKeyPair,\n    KeyChain as AVMKeyChain,\n    UTXOSet as AVMUTXOSet,\n    UTXO,\n    UnsignedTx,\n} from 'avalanche/dist/apis/avm'\nimport {\n    KeyPair as PlatformKeyPair,\n    KeyChain as PlatformKeyChain,\n    UTXOSet as PlatformUTXOSet,\n    UTXOSet,\n} from 'avalanche/dist/apis/platformvm'\nimport { KeyChain, KeyChain as EVMKeyChain, UTXOSet as EVMUTXOSet } from 'avalanche/dist/apis/evm'\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { buildUnsignedTransaction } from '../TxHelper'\nimport { AvaWalletCore, UnsafeWallet } from './types'\nimport { UTXO as PlatformUTXO } from 'avalanche/dist/apis/platformvm/utxos'\nimport { privateToAddress } from 'ethereumjs-util'\nimport { Tx as AVMTx, UnsignedTx as AVMUnsignedTx } from 'avalanche/dist/apis/avm/tx'\nimport {\n    Tx as PlatformTx,\n    UnsignedTx as PlatformUnsignedTx,\n} from 'avalanche/dist/apis/platformvm/tx'\nimport { Tx as EvmTx, UnsignedTx as EVMUnsignedTx } from 'avalanche/dist/apis/evm/tx'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletCore } from '@/js/wallets/WalletCore'\nimport { WalletHelper } from '@/helpers/wallet_helper'\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from '@/helpers/utxo_helper'\nimport { UTXO as AVMUTXO } from 'avalanche/dist/apis/avm/utxos'\nimport { Transaction } from '@ethereumjs/tx'\nimport { ExportChainsC, ExportChainsP, ExportChainsX } from '@avalabs/avalanche-wallet-sdk'\n\nclass SingletonWallet extends WalletCore implements AvaWalletCore, UnsafeWallet {\n    keyChain: AVMKeyChain\n    keyPair: AVMKeyPair\n\n    platformKeyChain: PlatformKeyChain\n    platformKeyPair: PlatformKeyPair\n\n    chainId: string\n    chainIdP: string\n\n    key: string\n\n    stakeAmount: BN\n\n    type: WalletNameType\n\n    ethKey: string\n    ethKeyBech: string\n    ethKeyChain: EVMKeyChain\n    ethAddress: string\n    ethAddressBech: string\n    ethBalance: BN\n\n    constructor(pk: string) {\n        super()\n\n        this.key = pk\n\n        this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID()\n        this.chainIdP = pChain.getBlockchainAlias() || pChain.getBlockchainID()\n\n        const hrp = ava.getHRP()\n\n        this.keyChain = new AVMKeyChain(hrp, this.chainId)\n        this.keyPair = this.keyChain.importKey(pk)\n\n        this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP)\n        this.platformKeyPair = this.platformKeyChain.importKey(pk)\n\n        this.stakeAmount = new BN(0)\n\n        // Derive EVM key and address\n        const pkBuf = bintools.cb58Decode(pk.split('-')[1])\n        const pkHex = pkBuf.toString('hex')\n        const pkBuffNative = Buffer.from(pkHex, 'hex')\n\n        this.ethKey = pkHex\n        this.ethAddress = privateToAddress(pkBuffNative).toString('hex')\n        this.ethBalance = new BN(0)\n\n        const cPrivKey = `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(pkBuf))\n        this.ethKeyBech = cPrivKey\n        const cKeyChain = new KeyChain(ava.getHRP(), 'C')\n        this.ethKeyChain = cKeyChain\n\n        const cKeypair = cKeyChain.importKey(cPrivKey)\n        this.ethAddressBech = cKeypair.getAddressString()\n\n        this.type = 'singleton'\n        this.isInit = true\n    }\n\n    getChangeAddressAvm(): string {\n        return this.getCurrentAddressAvm()\n    }\n\n    getCurrentAddressAvm(): string {\n        return this.keyPair.getAddressString()\n    }\n\n    getChangeAddressPlatform(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    getDerivedAddresses(): string[] {\n        const addr = this.getCurrentAddressAvm()\n        return [addr]\n    }\n\n    getDerivedAddressesP() {\n        return [this.getCurrentAddressPlatform()]\n    }\n\n    getAllDerivedExternalAddresses(): string[] {\n        return this.getDerivedAddresses()\n    }\n\n    getExtendedPlatformAddresses(): string[] {\n        const addr = this.platformKeyPair.getAddressString()\n        return [addr]\n    }\n\n    getHistoryAddresses(): string[] {\n        const addr = this.getCurrentAddressAvm()\n        return [addr]\n    }\n\n    getPlatformRewardAddress(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    getCurrentAddressPlatform(): string {\n        return this.platformKeyPair.getAddressString()\n    }\n\n    getBaseAddress(): string {\n        return this.getCurrentAddressAvm()\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    getPlatformUTXOSet(): PlatformUTXOSet {\n        return this.platformUtxoset\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    getEvmAddressBech(): string {\n        return this.ethAddressBech\n    }\n\n    async getEthBalance() {\n        const bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async updateUTXOsX(): Promise<AVMUTXOSet> {\n        const result = await avmGetAllUTXOs([this.getCurrentAddressAvm()])\n        this.utxoset = result\n        return result\n    }\n\n    async updateUTXOsP(): Promise<PlatformUTXOSet> {\n        const result = await platformGetAllUTXOs([this.getCurrentAddressPlatform()])\n        this.platformUtxoset = result\n        return result\n    }\n\n    async getUTXOs(): Promise<void> {\n        this.isFetchUtxos = true\n\n        await this.updateUTXOsX()\n        await this.updateUTXOsP()\n\n        await this.getStake()\n        await this.getEthBalance()\n\n        this.isFetchUtxos = false\n\n        return\n    }\n\n    async buildUnsignedTransaction(\n        orders: (ITransaction | UTXO)[],\n        addr: string,\n        memo?: BufferAvalanche\n    ) {\n        const changeAddress = this.getChangeAddressAvm()\n        const derivedAddresses = this.getDerivedAddresses()\n        const utxoset = this.getUTXOSet() as AVMUTXOSet\n\n        return buildUnsignedTransaction(\n            orders,\n            addr,\n            derivedAddresses,\n            utxoset,\n            changeAddress,\n            memo\n        )\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: BufferAvalanche | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    getFirstAvailableAddressPlatform(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    onnetworkchange(): void {\n        const hrp = ava.getHRP()\n\n        this.keyChain = new AVMKeyChain(hrp, this.chainId)\n        this.utxoset = new AVMUTXOSet()\n        this.keyPair = this.keyChain.importKey(this.key)\n\n        this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP)\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.platformKeyPair = this.platformKeyChain.importKey(this.key)\n\n        // Update EVM values\n        this.ethKeyChain = new EVMKeyChain(ava.getHRP(), 'C')\n        const cKeypair = this.ethKeyChain.importKey(this.ethKeyBech)\n        this.ethAddressBech = cKeypair.getAddressString()\n        this.ethBalance = new BN(0)\n\n        this.getUTXOs()\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        const keychain = this.keyChain\n\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        const keychain = this.platformKeyChain\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        const keyChain = this.ethKeyChain\n        return unsignedTx.sign(keyChain)\n    }\n\n    async signEvm(tx: Transaction) {\n        const keyBuff = Buffer.from(this.ethKey, 'hex')\n        return tx.sign(keyBuff)\n    }\n\n    async signMessage(msgStr: string): Promise<string> {\n        const digest = digestMessage(msgStr)\n\n        const digestHex = digest.toString('hex')\n        const digestBuff = BufferAvalanche.from(digestHex, 'hex')\n        const signed = this.keyPair.sign(digestBuff)\n\n        return bintools.cb58Encode(signed)\n    }\n\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number = 0,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n\n    getAllAddressesX() {\n        return [this.getCurrentAddressAvm()]\n    }\n\n    getAllAddressesP() {\n        return [this.getCurrentAddressPlatform()]\n    }\n}\n\nexport { SingletonWallet }\n","class AvaNftFamily {\n    id: string\n    name: string\n    symbol: string\n\n    constructor(id: string, name: string, symbol: string) {\n        this.id = id\n        this.name = name\n        this.symbol = symbol\n    }\n}\n\nexport { AvaNftFamily }\n","/*\nThe base wallet class used for common functionality\n*/\nimport { BN } from 'avalanche'\nimport { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm'\nimport {\n    ExportChainsC,\n    ExportChainsP,\n    ExportChainsX,\n    UtxoHelper,\n    TxHelper,\n    GasHelper,\n    chainIdFromAlias,\n    xChain,\n} from '@avalabs/avalanche-wallet-sdk'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { UTXOSet as EVMUTXOSet } from 'avalanche/dist/apis/evm/utxos'\nimport { Tx as EVMTx, UnsignedTx as EVMUnsignedTx } from 'avalanche/dist/apis/evm/tx'\nimport {\n    Tx as PlatformTx,\n    UnsignedTx as PlatformUnsignedTx,\n} from 'avalanche/dist/apis/platformvm/tx'\nimport { Tx as AVMTx, UnsignedTx as AVMUnsignedTx } from 'avalanche/dist/apis/avm/tx'\nimport { AvmImportChainType, WalletType } from '@/js/wallets/types'\nimport { issueC, issueP, issueX } from '@/helpers/issueTx'\nconst uniqid = require('uniqid')\n\nabstract class WalletCore {\n    id: string\n\n    utxoset: AVMUTXOSet\n    platformUtxoset: PlatformUTXOSet\n    stakeAmount: BN\n\n    isFetchUtxos: boolean\n    isInit: boolean\n\n    abstract getEvmAddressBech(): string\n    abstract getEvmAddress(): string\n    abstract getCurrentAddressAvm(): string\n    abstract getChangeAddressAvm(): string\n    abstract getCurrentAddressPlatform(): string\n    abstract getAllAddressesP(): string[]\n    abstract getAllAddressesX(): string[]\n\n    abstract async signC(unsignedTx: EVMUnsignedTx): Promise<EVMTx>\n    abstract async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx>\n    abstract async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx>\n\n    abstract async signMessage(msg: string, address?: string): Promise<string>\n    abstract getPlatformUTXOSet(): PlatformUTXOSet\n\n    getUTXOSet(): AVMUTXOSet {\n        return this.utxoset\n    }\n\n    protected constructor() {\n        this.id = uniqid()\n        this.utxoset = new AVMUTXOSet()\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.stakeAmount = new BN(0)\n\n        this.isInit = false\n        this.isFetchUtxos = false\n    }\n\n    async evmGetAtomicUTXOs(sourceChain: ExportChainsC) {\n        const addrs = [this.getEvmAddressBech()]\n        return await UtxoHelper.evmGetAtomicUTXOs(addrs, sourceChain)\n    }\n\n    async createImportTxC(sourceChain: ExportChainsC, utxoSet: EVMUTXOSet, fee: BN) {\n        const bechAddr = this.getEvmAddressBech()\n        const hexAddr = this.getEvmAddress()\n\n        const toAddress = '0x' + hexAddr\n        const ownerAddresses = [bechAddr]\n        const fromAddresses = ownerAddresses\n        const sourceChainId = chainIdFromAlias(sourceChain)\n\n        return await cChain.buildImportTx(\n            utxoSet,\n            toAddress,\n            ownerAddresses,\n            sourceChainId,\n            fromAddresses,\n            fee\n        )\n    }\n\n    /**\n     *\n     * @param sourceChain\n     * @param fee Fee to use in nDJTX\n     * @param utxoSet\n     */\n    async importToCChain(sourceChain: ExportChainsC, fee: BN, utxoSet?: EVMUTXOSet) {\n        if (!utxoSet) {\n            utxoSet = await this.evmGetAtomicUTXOs(sourceChain)\n        }\n\n        // TODO: Only use DJTX utxos\n        // TODO?: If the import fee for a utxo is greater than the value of the utxo, ignore it\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        const unsignedTxFee = await this.createImportTxC(sourceChain, utxoSet, fee)\n        const tx = await this.signC(unsignedTxFee)\n        return this.issueC(tx)\n    }\n\n    protected async issueX(tx: AVMTx) {\n        return issueX(tx)\n    }\n\n    protected async issueP(tx: PlatformTx) {\n        return issueP(tx)\n    }\n\n    protected async issueC(tx: EVMTx) {\n        return issueC(tx)\n    }\n\n    async exportFromXChain(amt: BN, destinationChain: ExportChainsX, importFee?: BN) {\n        if (destinationChain === 'C' && !importFee)\n            throw new Error('Exports to Utility chain must specify an import fee.')\n\n        let amtFee = amt.clone()\n\n        // Get destination address\n        const destinationAddr =\n            destinationChain === 'P' ? this.getCurrentAddressPlatform() : this.getEvmAddressBech()\n\n        // Add import fee to transaction\n        if (importFee) {\n            amtFee = amt.add(importFee)\n        } else if (destinationChain === 'P') {\n            const fee = pChain.getTxFee()\n            amtFee = amt.add(fee)\n        }\n\n        const fromAddresses = this.getAllAddressesX()\n        const changeAddress = this.getChangeAddressAvm()\n        const utxos = this.getUTXOSet()\n        const exportTx = await TxHelper.buildAvmExportTransaction(\n            destinationChain,\n            utxos,\n            fromAddresses,\n            destinationAddr,\n            amtFee,\n            changeAddress\n        )\n\n        const tx = await this.signX(exportTx)\n\n        return this.issueX(tx)\n    }\n\n    async exportFromPChain(amt: BN, destinationChain: ExportChainsP, importFee?: BN) {\n        const utxoSet = this.getPlatformUTXOSet()\n\n        const pChangeAddr = this.getCurrentAddressPlatform()\n        const fromAddrs = this.getAllAddressesP()\n\n        if (destinationChain === 'C' && !importFee)\n            throw new Error('Exports to Utility chain must specify an import fee.')\n\n        // Calculate C chain import fee\n        let amtFee = amt.clone()\n        if (importFee) {\n            amtFee = amt.add(importFee)\n        } else if (destinationChain === 'X') {\n            // We can add the import fee for X chain\n            const fee = avm.getTxFee()\n            amtFee = amt.add(fee)\n        }\n\n        // Get the destination address for the right chain\n        const destinationAddr =\n            destinationChain === 'C' ? this.getEvmAddressBech() : this.getCurrentAddressAvm()\n\n        const exportTx = await TxHelper.buildPlatformExportTransaction(\n            utxoSet,\n            fromAddrs,\n            destinationAddr,\n            amtFee,\n            pChangeAddr,\n            destinationChain\n        )\n\n        const tx = await this.signP(exportTx)\n        return await this.issueP(tx)\n    }\n\n    /**\n     *\n     * @param amt The amount to receive on the destination chain, in nDJTX.\n     * @param destinationChain `X` or `P`\n     * @param fee Fee to use in the export transaction, given in nDJTX.\n     */\n    async exportFromCChain(amt: BN, destinationChain: ExportChainsC, exportFee: BN) {\n        // Add import fee\n        // X and P have the same fee\n        const importFee = avm.getTxFee()\n        const amtFee = amt.add(importFee)\n\n        const hexAddr = this.getEvmAddress()\n        const bechAddr = this.getEvmAddressBech()\n\n        const fromAddresses = [hexAddr]\n\n        const destinationAddr =\n            destinationChain === 'X'\n                ? this.getCurrentAddressAvm()\n                : this.getCurrentAddressPlatform()\n\n        const exportTx = await TxHelper.buildEvmExportTransaction(\n            fromAddresses,\n            destinationAddr,\n            amtFee,\n            bechAddr,\n            destinationChain,\n            exportFee\n        )\n\n        const tx = await this.signC(exportTx)\n        return this.issueC(tx)\n    }\n\n    /**\n     * Returns the estimated gas to export from C chain.\n     * @param destinationChain\n     * @param amount\n     */\n    async estimateExportFee(destinationChain: ExportChainsC, amount: BN): Promise<number> {\n        const hexAddr = this.getEvmAddress()\n        const bechAddr = this.getEvmAddressBech()\n\n        const destinationAddr =\n            destinationChain === 'X'\n                ? this.getCurrentAddressAvm()\n                : this.getCurrentAddressPlatform()\n\n        return GasHelper.estimateExportGasFee(\n            destinationChain,\n            hexAddr,\n            bechAddr,\n            destinationAddr,\n            amount\n        )\n    }\n\n    async avmGetAtomicUTXOs(sourceChain: ExportChainsX) {\n        const addrs = this.getAllAddressesX()\n        return await UtxoHelper.avmGetAtomicUTXOs(addrs, sourceChain)\n    }\n\n    async platformGetAtomicUTXOs(sourceChain: ExportChainsP) {\n        const addrs = this.getAllAddressesP()\n        return await UtxoHelper.platformGetAtomicUTXOs(addrs, sourceChain)\n    }\n\n    async importToPlatformChain(sourceChain: ExportChainsP): Promise<string> {\n        const utxoSet = await this.platformGetAtomicUTXOs(sourceChain)\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        const sourceChainId = chainIdFromAlias(sourceChain)\n        // Owner addresses, the addresses we exported to\n        const pToAddr = this.getCurrentAddressPlatform()\n\n        const hrp = ava.getHRP()\n        const utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'P', addr))\n\n        const fromAddrs = utxoAddrs\n        const ownerAddrs = utxoAddrs\n\n        const unsignedTx = await pChain.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            sourceChainId,\n            [pToAddr],\n            [pToAddr],\n            [pToAddr],\n            undefined,\n            undefined\n        )\n        const tx = await this.signP(unsignedTx)\n        // Pass in string because AJS fails to verify Tx type\n        return this.issueP(tx)\n    }\n\n    async importToXChain(sourceChain: AvmImportChainType) {\n        const utxoSet = await this.avmGetAtomicUTXOs(sourceChain)\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        const xToAddr = this.getCurrentAddressAvm()\n\n        const hrp = ava.getHRP()\n        const utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'X', addr))\n\n        const fromAddrs = utxoAddrs\n        const ownerAddrs = utxoAddrs\n\n        const sourceChainId = chainIdFromAlias(sourceChain)\n\n        // Owner addresses, the addresses we exported to\n        const unsignedTx = await avm.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            sourceChainId,\n            [xToAddr],\n            fromAddrs,\n            [xToAddr]\n        )\n\n        const tx = await this.signX(unsignedTx)\n        return this.issueX(tx)\n    }\n}\nexport { WalletCore }\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport {\n    UTXOSet as PlatformUTXOSet,\n    UTXO as PlatformUTXO,\n} from 'avalanche/dist/apis/platformvm/utxos'\nimport { UTXO as AVMUTXO } from 'avalanche/dist/apis/avm/utxos'\nimport { WalletType } from '@/js/wallets/types'\n\nimport { BN, Buffer } from 'avalanche'\nimport {\n    buildCreateNftFamilyTx,\n    buildEvmTransferErc20Tx,\n    buildEvmTransferErc721Tx,\n    buildEvmTransferNativeTx,\n    buildMintNftTx,\n} from '@/js/TxHelper'\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { ITransaction } from '@/components/wallet/transfer/types'\n\nimport { web3 } from '@/evm'\nimport Erc20Token from '@/js/Erc20Token'\nimport { getStakeForAddresses } from '@/helpers/utxo_helper'\nimport ERC721Token from '@/js/ERC721Token'\nimport { issueP, issueX } from '@/helpers/issueTx'\n\nclass WalletHelper {\n    static async getStake(wallet: WalletType): Promise<BN> {\n        const addrs = wallet.getAllAddressesP()\n        return await getStakeForAddresses(addrs)\n    }\n\n    static async createNftFamily(\n        wallet: WalletType,\n        name: string,\n        symbol: string,\n        groupNum: number\n    ) {\n        const fromAddresses = wallet.getDerivedAddresses()\n        const changeAddress = wallet.getChangeAddressAvm()\n\n        const minterAddress = wallet.getCurrentAddressAvm()\n\n        const utxoSet = wallet.getUTXOSet()\n\n        const unsignedTx = await buildCreateNftFamilyTx(\n            name,\n            symbol,\n            groupNum,\n            fromAddresses,\n            minterAddress,\n            changeAddress,\n            utxoSet\n        )\n\n        const signed = await wallet.signX(unsignedTx)\n        return issueX(signed)\n    }\n\n    static async mintNft(\n        wallet: WalletType,\n        mintUtxo: AVMUTXO,\n        payload: PayloadBase,\n        quantity: number\n    ) {\n        const ownerAddress = wallet.getCurrentAddressAvm()\n        const changeAddress = wallet.getChangeAddressAvm()\n\n        const sourceAddresses = wallet.getDerivedAddresses()\n\n        const utxoSet = wallet.getUTXOSet()\n        const tx = await buildMintNftTx(\n            mintUtxo,\n            payload,\n            quantity,\n            ownerAddress,\n            changeAddress,\n            sourceAddresses,\n            utxoSet\n        )\n        const signed = await wallet.signX(tx)\n        return issueX(signed)\n    }\n\n    static async issueBatchTx(\n        wallet: WalletType,\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: Buffer | undefined\n    ): Promise<string> {\n        const unsignedTx = await wallet.buildUnsignedTransaction(orders, addr, memo)\n        const tx = await wallet.signX(unsignedTx)\n        const txId: string = await issueX(tx)\n\n        return txId\n    }\n\n    static async validate(\n        wallet: WalletType,\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let utxoSet = wallet.getPlatformUTXOSet()\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        const pAddressStrings = wallet.getAllAddressesP()\n\n        const stakeAmount = amt\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = wallet.getPlatformRewardAddress()\n        }\n\n        // For change address use first available on the platform chain\n        const changeAddress = wallet.getFirstAvailableAddressPlatform()\n\n        const stakeReturnAddr = wallet.getCurrentAddressPlatform()\n\n        // Convert dates to unix time\n        const startTime = new BN(Math.round(start.getTime() / 1000))\n        const endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddValidatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings, // from\n            [changeAddress], // change\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress],\n            delegationFee\n        )\n\n        const tx = await wallet.signP(unsignedTx)\n        return issueP(tx)\n    }\n\n    static async delegate(\n        wallet: WalletType,\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let utxoSet = wallet.getPlatformUTXOSet()\n        const pAddressStrings = wallet.getAllAddressesP()\n\n        const stakeAmount = amt\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = wallet.getPlatformRewardAddress()\n        }\n\n        const stakeReturnAddr = wallet.getPlatformRewardAddress()\n\n        // For change address use first available on the platform chain\n        const changeAddress = wallet.getFirstAvailableAddressPlatform()\n\n        // Convert dates to unix time\n        const startTime = new BN(Math.round(start.getTime() / 1000))\n        const endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddDelegatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings,\n            [changeAddress],\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress] // reward address\n        )\n\n        const tx = await wallet.signP(unsignedTx)\n        return issueP(tx)\n    }\n\n    static async getEthBalance(wallet: WalletType) {\n        const bal = await web3.eth.getBalance(wallet.ethAddress)\n        return new BN(bal)\n    }\n\n    static async sendEth(\n        wallet: WalletType,\n        to: string,\n        amount: BN, // in wei\n        gasPrice: BN,\n        gasLimit: number\n    ) {\n        const fromAddr = '0x' + wallet.getEvmAddress()\n\n        const tx = await buildEvmTransferNativeTx(fromAddr, to, amount, gasPrice, gasLimit)\n\n        const signedTx = await wallet.signEvm(tx)\n\n        const txHex = signedTx.serialize().toString('hex')\n        const hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async sendErc20(\n        wallet: WalletType,\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ) {\n        const fromAddr = '0x' + wallet.getEvmAddress()\n        const tx = await buildEvmTransferErc20Tx(fromAddr, to, amount, gasPrice, gasLimit, token)\n\n        const signedTx = await wallet.signEvm(tx)\n        const txHex = signedTx.serialize().toString('hex')\n        const hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async sendErc721(\n        wallet: WalletType,\n        to: string,\n        gasPrice: BN,\n        gasLimit: number,\n        token: ERC721Token,\n        tokenId: string\n    ) {\n        const fromAddr = '0x' + wallet.getEvmAddress()\n        const tx = await buildEvmTransferErc721Tx(fromAddr, to, gasPrice, gasLimit, token, tokenId)\n        const signedTx = await wallet.signEvm(tx)\n        const txHex = signedTx.serialize().toString('hex')\n        const hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async estimateTxGas(wallet: WalletType, tx: any) {\n        const fromAddr = '0x' + wallet.getEvmAddress()\n        const estGas = await tx.estimateGas({ from: fromAddr })\n        return Math.round(estGas * 1.1)\n    }\n\n    static async estimateGas(wallet: WalletType, to: string, amount: BN, token: Erc20Token) {\n        const from = '0x' + wallet.getEvmAddress()\n        const tx = token.createTransferTx(to, amount)\n        const estGas = await tx.estimateGas({\n            from: from,\n        })\n        // Return 10% more\n        return Math.round(estGas * 1.1)\n    }\n}\n\nexport { WalletHelper }\n","import { ava } from '@/AVA'\n\nimport {\n    KeyChain as AVMKeyChain,\n    KeyPair as AVMKeyPair,\n    NFTTransferOutput,\n    UTXO,\n} from 'avalanche/dist/apis/avm'\n\nimport { Defaults, getPreferredHRP, ONEDJTX, PayloadBase, PayloadTypes } from 'avalanche/dist/utils'\nimport Big from 'big.js'\n\nimport { Buffer, BN } from 'avalanche'\nimport createHash from 'create-hash'\n\nfunction bnToBig(val: BN, denomination = 0): Big {\n    return new Big(val.toString()).div(Math.pow(10, denomination))\n}\n\nfunction keyToKeypair(key: string, chainID: string = 'X'): AVMKeyPair {\n    const hrp = getPreferredHRP(ava.getNetworkID())\n    const keychain = new AVMKeyChain(hrp, chainID)\n    return keychain.importKey(key)\n}\n\nfunction calculateStakingReward(amount: BN, duration: number, currentSupply: BN): BN {\n    const networkID = ava.getNetworkID()\n\n    //@ts-ignore\n    const defValues = Defaults.network[networkID]\n\n    if (!defValues) {\n        console.error('Network default values not found.')\n        return new BN(0)\n    }\n    const defPlatformVals = defValues.P\n\n    const maxConsumption: number = defPlatformVals.maxConsumption\n    const minConsumption: number = defPlatformVals.minConsumption\n    const diffConsumption = maxConsumption - minConsumption\n    const maxSupply: BN = defPlatformVals.maxSupply\n    const maxStakingDuration: BN = defPlatformVals.maxStakingDuration\n    const remainingSupply = maxSupply.sub(currentSupply)\n\n    const amtBig = Big(amount.div(ONEDJTX).toString())\n    const currentSupplyBig = Big(currentSupply.div(ONEDJTX).toString())\n    const remainingSupplyBig = Big(remainingSupply.div(ONEDJTX).toString())\n    const portionOfExistingSupplyBig = amtBig.div(currentSupplyBig)\n\n    const portionOfStakingDuration = duration / maxStakingDuration.toNumber()\n    const mintingRate = minConsumption + diffConsumption * portionOfStakingDuration\n\n    let rewardBig: Big = remainingSupplyBig.times(portionOfExistingSupplyBig)\n    rewardBig = rewardBig.times(Big(mintingRate * portionOfStakingDuration))\n\n    const rewardStr = rewardBig.times(Math.pow(10, 9)).toFixed(0)\n    const rewardBN = new BN(rewardStr)\n\n    return rewardBN\n}\n\nfunction digestMessage(msgStr: string) {\n    const mBuf = Buffer.from(msgStr, 'utf8')\n    const msgSize = Buffer.alloc(4)\n    msgSize.writeUInt32BE(mBuf.length, 0)\n    const msgBuf = Buffer.from(`\\x1AAvalanche Signed Message:\\n${msgSize}${msgStr}`, 'utf8')\n    return createHash('sha256').update(msgBuf).digest()\n}\n\nconst payloadtypes = PayloadTypes.getInstance()\n\nfunction getPayloadFromUTXO(utxo: UTXO): PayloadBase {\n    const out = utxo.getOutput() as NFTTransferOutput\n    const payload = out.getPayloadBuffer()\n\n    const typeId = payloadtypes.getTypeID(payload)\n    const pl: Buffer = payloadtypes.getContent(payload)\n    const payloadbase: PayloadBase = payloadtypes.select(typeId, pl)\n\n    return payloadbase\n}\n\nexport { keyToKeypair, calculateStakingReward, bnToBig, digestMessage, getPayloadFromUTXO }\n","// Manages BigNumber and Ava conversion and arithmetic\nimport { BN } from 'avalanche'\nimport Big from 'big.js'\n\nclass AvaAsset {\n    id: string\n    name: string\n    symbol: string\n    denomination: number\n    amount: BN\n    amountLocked: BN\n    amountMultisig: BN\n    // DJTX P chain, Wallet Staking\n    amountExtra: BN\n    private readonly pow: Big\n    constructor(id: string, name: string, symbol: string, denomination: number) {\n        this.id = id\n        this.name = name\n        this.symbol = symbol\n        this.denomination = denomination\n        this.amount = new BN(0, 10)\n        this.amountLocked = new BN(0, 10)\n        this.amountExtra = new BN(0, 10)\n        this.amountMultisig = new BN(0, 10)\n        this.pow = Big(10).pow(denomination)\n    }\n\n    addBalance(val: BN): void {\n        this.amount = this.amount.add(val)\n    }\n\n    addBalanceLocked(val: BN): void {\n        this.amountLocked = this.amountLocked.add(val)\n    }\n    addBalanceMultisig(val: BN): void {\n        this.amountMultisig = this.amountMultisig.add(val)\n    }\n\n    addExtra(val: BN): void {\n        this.amountExtra = this.amountExtra.add(val)\n    }\n\n    resetBalance() {\n        this.amount = new BN(0, 10)\n        this.amountLocked = new BN(0, 10)\n        this.amountExtra = new BN(0, 10)\n        this.amountMultisig = new BN(0, 10)\n    }\n\n    getAmount(locked: boolean = false): Big {\n        if (!locked) {\n            return Big(this.amount.toString(10)).div(this.pow)\n        } else {\n            return Big(this.amountLocked.toString(10)).div(this.pow)\n        }\n    }\n\n    getAmountBN(locked: boolean = false): BN {\n        if (!locked) {\n            return this.amount\n        } else {\n            return this.amountLocked\n        }\n    }\n\n    getTotalAmount(): BN {\n        return this.amount.add(this.amountLocked).add(this.amountExtra).add(this.amountMultisig)\n    }\n\n    toStringTotal(): string {\n        const big: Big = Big(this.getTotalAmount().toString(10)).div(this.pow)\n        return big.toLocaleString(this.denomination)\n    }\n\n    toString() {\n        const big: Big = Big(this.amount.toString(10)).div(this.pow)\n        return big.toLocaleString(this.denomination)\n    }\n}\n\nexport default AvaAsset\n"],"sourceRoot":""}